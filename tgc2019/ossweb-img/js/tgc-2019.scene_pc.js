webpackJsonp([4],{

/***/ "+V8t":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "1HRj":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "2Uim":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "3guR":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mockPartners = mockPartners;
exports.mockNewslistData = mockNewslistData;
exports.default = {
    navbar: {
        navs: [{
            title: "CJ2019",
            key: "home",
            url: "/2019/index.html",
            mUrl: "/2019/m/index.html"
        }, {
            title: "关于TGC",
            key: "about",
            url: "/2019/about.html",
            mUrl: "/2019/m/about.html"
        }, {
            title: "最新资讯",
            key: "news",
            url: "/2019/newslist.html",
            mUrl: "/2019/m/newslist.html"
        }, {
            title: "现场详情",
            key: "scene",
            // url: "/2019/scene.html",
            // mUrl: "/2019/m/scene.html"
            url: "javascript:alert('敬请期待')",
            mUrl: "javascript:alert('敬请期待')",
        }, {
            title: "",
            key: "living",
            // url: "/2019/living.html",
            // mUrl: "/2019/m/living.html"
            url: "javascript:alert('敬请期待')",
            mUrl: "javascript:alert('敬请期待')",
        }],
        logo: __webpack_require__("ZmHP"),
        // smoothScroll: true,
        // smoothScrollOffset: 30,
        offsetTop: 0
    },
    scene: {
        tabs: [{
            title: '场馆指引',
            key: 'venue',
            url: '#venue'
        },
        // {
        //     title: '活动日程',
        //     key: 'agenda',
        //     url: '#agenda',
        // },
        {
            title: '周边地图',
            key: 'maps',
            url: '#maps'
        }, {
            title: '帮助中心',
            key: 'helps',
            url: '#helps'
        }]
    },
    helps: {
        list: [{
            title: "TGC2019的活动时间/地点？",
            lines: ['<strong>活动时间：</strong>2019年1月17日至2019年1月20日', '<strong>活动地点：</strong>成都，新世纪环球中心<br/>成都市武侯区天府大道北段1700号']
        }, {
            title: "有关TGC2019的购票信息",
            lines: ['<strong>售票渠道：</strong>猫眼演出/猫眼APP', '<strong>售票时间：</strong>2019年1月9日至1月20日', '<strong>票价：</strong>单场门票18元（由于每天的门票分上、下午两场，请购买门票时注意场次，过期失效）']
        }, {
            title: "购买TGC2019门票可获得的权益？",
            lines: ['海洋公园内凭票入场，其余区域无需门票，门票当日单场有效。', '【上午场】10:00至14:30', '【下午场】15:00至20:00']
        }, {
            title: "官网购买的门票是否可退换？",
            lines: ['门票一经售出无法退换，请提前确认好行程及购买场次。如不确定，可活动当天至现场售票处购票。如遇人流高峰，需要等待排队入场。']
        }, {
            title: "购票后是否可获得发票？",
            lines: ['门票购买后可提供发票，请联系猫眼演出客服，客服热线：10105335。']
        }]
    },
    // 周边地图经纬度
    mapLatLng: {
        lat: 30.568871,
        lng: 104.065376
    },
    carouselNews: {
        list: [{
            title: "slide 1",
            img: "//game.gtimg.cn/images/game/2018/common/img/defaults/default-slide.jpg",
            url: "http://up.qq.com/webplat/info/news_version3/7694/34951/35283/35364/m20491/201804/712026.shtml"
        }, {
            title: "slide 2",
            img: "//game.gtimg.cn/images/game/2018/common/img/defaults/default-slide.jpg",
            url: "http://up.qq.com/webplat/info/news_version3/7694/34951/35283/35364/m20491/201804/712026.shtml"
        }, {
            title: "slide 3",
            img: "//game.gtimg.cn/images/game/2018/common/img/defaults/default-slide.jpg",
            url: "http://up.qq.com/webplat/info/news_version3/7694/34951/35283/35364/m20491/201804/712026.shtml"
        }, {
            title: "slide 4",
            img: "//game.gtimg.cn/images/game/2018/common/img/defaults/default-slide.jpg",
            url: "http://up.qq.com/webplat/info/news_version3/7694/34951/35283/35364/m20491/201804/712026.shtml"
        }]
    },
    gicpBizId: 148,
    // 新闻列表tab的v4配置
    newsTabList: {
        pc: [{
            title: "全部",
            // id: 8325,
            id: 3769,
            tag: 'iTarget'
        }],
        m: [{
            title: "全部",
            // id: 8329,
            id: 3770,
            tag: 'iTarget'
        }]
    },
    // 新闻轮播图的v4配置 
    newsCarousel: {
        pc: 8335,
        m: 8336
    },
    // 合作伙伴的v4配置
    partners: {
        pc: [{
            title: '指导单位',
            id: 8468
        }, {
            title: '主办方',
            id: 8398
        }, {
            title: '场地合作方',
            id: 8399
        }, {
            title: '参展品牌及业务',
            id: 8400,
            page: 1
        }, {
            title: '参展品牌及业务',
            id: 8400,
            page: 2
        }, {
            title: '合作伙伴',
            id: 8401
        }],
        m: [{
            title: '指导单位',
            id: 8469
        }, {
            title: '主办方',
            id: 8403
        }, {
            title: '场地合作方',
            id: 8404
        }, {
            title: '参展品牌及业务',
            id: 8405,
            page: 1
        }, {
            title: '参展品牌及业务',
            id: 8405,
            page: 2
        }, {
            title: '合作伙伴',
            id: 8406
        }]
    },
    cci: {
        pc: 8390,
        m: 8391
    },
    // 广告
    ads: {
        pc: 8337,
        m: 8338
    },
    living: {
        tabs: [{
            title: "1月17日",
            id: 8384
        }, {
            title: "1月18日",
            id: 8385
        }, {
            title: "1月19日",
            id: 8386
        }, {
            title: "1月20日",
            id: 8387
        }]
    },
    misc: {
        list: [["联系电话：+86 xxx-xxx-xxx", "商务合作：xxx@tencent.com", "公司地址：深圳市南山区xxxxxxx"], ["客服办公时间：周一至周日 9:00-21:00", "客服支持：xxx@tencent.com"]]
    },
    vid: {
        vid: "y0827w3qjnv"
    },
    lpQrcode: {
        img: __webpack_require__("cK//")
    }
};
function mockPartners() {
    var img = "//game.gtimg.cn/images/game/2018/common/img/defaults/default-slide.jpg";
    var imgs = [];
    for (var i = 0; i < 24; i++) {
        imgs.push(img);
    }

    return {
        imgs: imgs
    };
}

function mockNewslistData() {
    var tabs = ["全部", "赛事", "活动", "科技新游"];
    var item = {
        title: "光荣之巅-单排鸡王争霸赛报名开始！",
        abs: "内容摘要内容摘要内容摘要内容摘要内容摘要内容摘要内容摘要内容摘要内容摘要内容摘要内容摘要内容摘要",
        img: "//game.gtimg.cn/images/game/2018/common/img/defaults/default-slide.jpg",
        url: "/webplat/info/news_version3/32644/33111/33214/33215/m19346/201803/698167.shtml",
        release: "03/08",
        tag: "hot"
    };

    var data = tabs.map(function (tab) {
        var title = tab;
        var list = [];
        for (var i = 0; i < 5; i++) {
            list.push(item);
        }

        return {
            title: title,
            list: list
        };
    });

    return {
        tabs: data
    };
}

/***/ }),

/***/ "5UW2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (selector, options) {
    var $container = $(selector);

    init();

    function init() {
        render();
        fixFloatAreaPos();
    }

    function render() {
        var html = (0, _index2.default)({
            qrcode: _qrLg2.default,
            livingUrl: _index4.default.navbar.navs[4].url
        });
        $container.html(html);
    }

    // 修正二维码浮层的位置
    function fixFloatAreaPos() {
        var $float = $('.float-qrcode');
        var winW = $(window).width();
        var winH = $(window).height();
        var qrcodeH = $float.height();
        var limit = 1870;
        // 超过1200则让浮层在1200的主体内容最右边
        if (winW >= limit) {
            var rightMargin = (winW - limit) / 2;
            $float.css('right', rightMargin);
        } else {
            $float.css('right', 0);
        }
        // 垂直居中
        $float.css('top', Math.round((winH - qrcodeH) / 2));
    }
};

__webpack_require__("1HRj");

var _index = __webpack_require__("Rnay");

var _index2 = _interopRequireDefault(_index);

var _qrLg = __webpack_require__("cK//");

var _qrLg2 = _interopRequireDefault(_qrLg);

var _index3 = __webpack_require__("3guR");

var _index4 = _interopRequireDefault(_index3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ "5WOt":
/***/ (function(module, exports, __webpack_require__) {

var $imports = __webpack_require__("+ObC");
module.exports = function ($data) {
    'use strict';
    $data = $data || {};
    var $$out = '', $escape = $imports.$escape, logo = $data.logo, $each = $imports.$each, navs = $data.navs, nav = $data.nav, index = $data.index, cur = $data.cur, smoothScroll = $data.smoothScroll;
    $$out += '<div class="blocks-navbar-pc-affix">\r\n    <div class="affix">\r\n        <div class="content">\r\n            <div class="logo"><img src="';
    $$out += $escape(logo);
    $$out += '" alt="logo"></div>\r\n            <ul class="">\r\n                ';
    $each(navs, function (nav, index) {
        $$out += '\r\n                <li class="';
        if (cur == nav.key) {
            $$out += 'on';
        }
        $$out += '">\r\n                    <a href="';
        if (smoothScroll) {
            $$out += 'javascript:;';
        } else {
            $$out += $escape(nav.url);
        }
        $$out += '" onclick="PTTSendClick(\'nav\',\'';
        $$out += $escape(nav.key);
        $$out += '\',\'';
        $$out += $escape(nav.title);
        $$out += '\');">';
        $$out += $escape(nav.title);
        $$out += '</a>\r\n                </li>\r\n                ';
    });
    $$out += '\r\n            </ul>\r\n        </div>\r\n    </div>\r\n    <div class="shim"></div>\r\n</div>';
    return $$out;
};

/***/ }),

/***/ "9y5s":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("+V8t");

__webpack_require__("2Uim");

var _index = __webpack_require__("3guR");

var _index2 = _interopRequireDefault(_index);

var _utils = __webpack_require__("fdFc");

var _index3 = __webpack_require__("ayFF");

var _index4 = _interopRequireDefault(_index3);

var _index5 = __webpack_require__("n8ar");

var _index6 = _interopRequireDefault(_index5);

var _index7 = __webpack_require__("UElg");

var _index8 = _interopRequireDefault(_index7);

var _index9 = __webpack_require__("5UW2");

var _index10 = _interopRequireDefault(_index9);

var _mapGuide = __webpack_require__("j8AK");

var _mapGuide2 = _interopRequireDefault(_mapGuide);

var _helps = __webpack_require__("skTu");

var _helps2 = _interopRequireDefault(_helps);

__webpack_require__("d9Wh");

var _mapinfo = __webpack_require__("jxHD");

var _mapinfo2 = _interopRequireDefault(_mapinfo);

__webpack_require__("KPmn");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 玩转成都
// import playTabData from "../../common/data/playCd";
// import TabPlay from "../../modules/blocks-tabs-play-cd/pc/index";
// 活动日程
// import agendaData from "../../common/data/agenda";
// import TabAgenda from "../../modules/blocks-tabs-agenda/pc/index";
// 周边地图

// 帮助页面
init();
// 场馆指引


// modules


function init() {
    (0, _utils.makePcFrameworkCenter)();
    initSyncMods();
}

function initSyncMods() {
    // 导航栏
    _index2.default.navbar.cur = 'scene';
    (0, _index4.default)('.mod-navbar', {
        data: _index2.default.navbar
    });
    (0, _index6.default)('.mod-footer', {});
    (0, _index10.default)(".mod-float-qrcode", {});
    // 外层tab
    (0, _index8.default)('.mod-tabs-scene', {
        data: _index2.default.scene
    });

    initPages();
}

// 初始化tab里的页面
function initPages() {
    // 渲染场馆指引
    initMapGuidePage();
    // 渲染帮助页
    initHelpsPage();
    // 渲染玩转成都
    // initPlayPage();
    // 渲染日程安排
    // initAgendaPage();
    // 渲染周边地图
    initMapInfo();
}

/**
 * 获取对应key的tab-content的选择器
 * @param {string} key 子页面的key，比如helps
 */
function getTabContentSelector(key) {
    return ".mod-tabs-scene .tab-content-" + key;
}

function initMapGuidePage() {
    var selector = getTabContentSelector('venue');
    (0, _mapGuide2.default)(selector);
}

function initHelpsPage() {
    var selector = getTabContentSelector('helps');
    var html = (0, _helps2.default)(_index2.default.helps);

    $(selector).html(html);
}

function initPlayPage() {
    var selector = getTabContentSelector('play');

    TabPlay(selector, {
        data: playTabData
    });
}

function initAgendaPage() {
    var selector = getTabContentSelector('agenda');

    TabAgenda(selector, {
        data: removeBrInAgendaData(agendaData)
    });
}

function removeBrInAgendaData(data) {
    return {
        tabs: data.tabs.map(function (tab) {
            tab.list = tab.list.map(function (item) {
                return {
                    time: item.time.replace(/\<br\s*\/\>/g, ""),
                    desc: item.desc
                };
            });
            return tab;
        })
    };
}

function initMapInfo() {
    var selector = getTabContentSelector('maps');
    var html = (0, _mapinfo2.default)();

    $(selector).html(html);

    initTXMap();
}

function initTXMap() {
    var latlng = new qq.maps.LatLng(_index2.default.mapLatLng.lat, _index2.default.mapLatLng.lng);
    var opt = {
        center: latlng,
        zoom: 15
    };

    var map = new qq.maps.Map($('#around-map').get(0), opt);
    var marker = new qq.maps.Marker({
        position: latlng,
        map: map
    });
    var label = new qq.maps.Label({
        position: latlng,
        map: map,
        content: "成都新世纪环球中心"
    });
}

/***/ }),

/***/ "DyQB":
/***/ (function(module, exports, __webpack_require__) {

var $imports = __webpack_require__("+ObC");
module.exports = function ($data) {
    'use strict';
    $data = $data || {};
    var $$out = '', $each = $imports.$each, tabs = $data.tabs, tab = $data.tab, index = $data.index, cur = $data.cur, $escape = $imports.$escape;
    $$out += '<div class="blocks-tabs-scene">\r\n    <ul class="tabs">\r\n        ';
    $each(tabs, function (tab, index) {
        $$out += '\r\n        <li ';
        if (tab.key === cur) {
            $$out += 'class="on"';
        }
        $$out += '>';
        $$out += $escape(tab.title);
        $$out += '</li>\r\n        ';
    });
    $$out += '\r\n    </ul>\r\n    <div class="content-wrapper">\r\n        ';
    $each(tabs, function (tab, index) {
        $$out += '\r\n        <div class="tab-content tab-content-';
        $$out += $escape(tab.key);
        $$out += ' ';
        if (tab.key === cur) {
            $$out += 'on';
        }
        $$out += '"></div>\r\n        ';
    });
    $$out += '\r\n    </div>\r\n</div>';
    return $$out;
};

/***/ }),

/***/ "Fl7+":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! iScroll v5.1.3 ~ (c) 2008-2014 Matteo Spinelli ~ //cubiq.org/license */
(function (window, document, Math) {
    var rAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
        window.setTimeout(callback, 1000 / 60);
    };

    var utils = function () {
        var me = {};

        var _elementStyle = document.createElement("div").style;
        var _vendor = function () {
            var vendors = ["t", "webkitT", "MozT", "msT", "OT"],
                transform,
                i = 0,
                l = vendors.length;

            for (; i < l; i++) {
                transform = vendors[i] + "ransform";
                if (transform in _elementStyle) return vendors[i].substr(0, vendors[i].length - 1);
            }

            return false;
        }();

        function _prefixStyle(style) {
            if (_vendor === false) return false;
            if (_vendor === "") return style;
            return _vendor + style.charAt(0).toUpperCase() + style.substr(1);
        }

        me.getTime = Date.now || function getTime() {
            return new Date().getTime();
        };

        me.extend = function (target, obj) {
            for (var i in obj) {
                target[i] = obj[i];
            }
        };

        me.addEvent = function (el, type, fn, capture) {
            el.addEventListener(type, fn, !!capture);
        };

        me.removeEvent = function (el, type, fn, capture) {
            el.removeEventListener(type, fn, !!capture);
        };

        me.prefixPointerEvent = function (pointerEvent) {
            return window.MSPointerEvent ? "MSPointer" + pointerEvent.charAt(9).toUpperCase() + pointerEvent.substr(10) : pointerEvent;
        };

        me.momentum = function (current, start, time, lowerMargin, wrapperSize, deceleration) {
            var distance = current - start,
                speed = Math.abs(distance) / time,
                destination,
                duration;

            deceleration = deceleration === undefined ? 0.0006 : deceleration;

            destination = current + speed * speed / (2 * deceleration) * (distance < 0 ? -1 : 1);
            duration = speed / deceleration;

            if (destination < lowerMargin) {
                destination = wrapperSize ? lowerMargin - wrapperSize / 2.5 * (speed / 8) : lowerMargin;
                distance = Math.abs(destination - current);
                duration = distance / speed;
            } else if (destination > 0) {
                destination = wrapperSize ? wrapperSize / 2.5 * (speed / 8) : 0;
                distance = Math.abs(current) + destination;
                duration = distance / speed;
            }

            return {
                destination: Math.round(destination),
                duration: duration
            };
        };

        var _transform = _prefixStyle("transform");

        me.extend(me, {
            hasTransform: _transform !== false,
            hasPerspective: _prefixStyle("perspective") in _elementStyle,
            hasTouch: "ontouchstart" in window,
            hasPointer: window.PointerEvent || window.MSPointerEvent, // IE10 is prefixed
            hasTransition: _prefixStyle("transition") in _elementStyle
        });

        // This should find all Android browsers lower than build 535.19 (both stock browser and webview)
        me.isBadAndroid = /Android /.test(window.navigator.appVersion) && !/Chrome\/\d/.test(window.navigator.appVersion);

        me.extend(me.style = {}, {
            transform: _transform,
            transitionTimingFunction: _prefixStyle("transitionTimingFunction"),
            transitionDuration: _prefixStyle("transitionDuration"),
            transitionDelay: _prefixStyle("transitionDelay"),
            transformOrigin: _prefixStyle("transformOrigin")
        });

        me.hasClass = function (e, c) {
            var re = new RegExp("(^|\\s)" + c + "(\\s|$)");
            return re.test(e.className);
        };

        me.addClass = function (e, c) {
            if (me.hasClass(e, c)) {
                return;
            }

            var newclass = e.className.split(" ");
            newclass.push(c);
            e.className = newclass.join(" ");
        };

        me.removeClass = function (e, c) {
            if (!me.hasClass(e, c)) {
                return;
            }

            var re = new RegExp("(^|\\s)" + c + "(\\s|$)", "g");
            e.className = e.className.replace(re, " ");
        };

        me.offset = function (el) {
            var left = -el.offsetLeft,
                top = -el.offsetTop;

            // jshint -W084
            while (el = el.offsetParent) {
                left -= el.offsetLeft;
                top -= el.offsetTop;
            }
            // jshint +W084

            return {
                left: left,
                top: top
            };
        };

        me.preventDefaultException = function (el, exceptions) {
            for (var i in exceptions) {
                if (exceptions[i].test(el[i])) {
                    return true;
                }
            }

            return false;
        };

        me.extend(me.eventType = {}, {
            touchstart: 1,
            touchmove: 1,
            touchend: 1,

            mousedown: 2,
            mousemove: 2,
            mouseup: 2,

            pointerdown: 3,
            pointermove: 3,
            pointerup: 3,

            MSPointerDown: 3,
            MSPointerMove: 3,
            MSPointerUp: 3
        });

        me.extend(me.ease = {}, {
            quadratic: {
                style: "cubic-bezier(0.25, 0.46, 0.45, 0.94)",
                fn: function fn(k) {
                    return k * (2 - k);
                }
            },
            circular: {
                style: "cubic-bezier(0.1, 0.57, 0.1, 1)", // Not properly "circular" but this looks better, it should be (0.075, 0.82, 0.165, 1)
                fn: function fn(k) {
                    return Math.sqrt(1 - --k * k);
                }
            },
            back: {
                style: "cubic-bezier(0.175, 0.885, 0.32, 1.275)",
                fn: function fn(k) {
                    var b = 4;
                    return (k = k - 1) * k * ((b + 1) * k + b) + 1;
                }
            },
            bounce: {
                style: "",
                fn: function fn(k) {
                    if ((k /= 1) < 1 / 2.75) {
                        return 7.5625 * k * k;
                    } else if (k < 2 / 2.75) {
                        return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
                    } else if (k < 2.5 / 2.75) {
                        return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
                    } else {
                        return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
                    }
                }
            },
            elastic: {
                style: "",
                fn: function fn(k) {
                    var f = 0.22,
                        e = 0.4;

                    if (k === 0) {
                        return 0;
                    }
                    if (k == 1) {
                        return 1;
                    }

                    return e * Math.pow(2, -10 * k) * Math.sin((k - f / 4) * (2 * Math.PI) / f) + 1;
                }
            }
        });

        me.tap = function (e, eventName) {
            var ev = document.createEvent("Event");
            ev.initEvent(eventName, true, true);
            ev.pageX = e.pageX;
            ev.pageY = e.pageY;
            e.target.dispatchEvent(ev);
        };

        me.click = function (e) {
            var target = e.target,
                ev;

            if (!/(SELECT|INPUT|TEXTAREA)/i.test(target.tagName)) {
                ev = document.createEvent("MouseEvents");
                ev.initMouseEvent("click", true, true, e.view, 1, target.screenX, target.screenY, target.clientX, target.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, 0, null);

                ev._constructed = true;
                target.dispatchEvent(ev);
            }
        };

        return me;
    }();

    function IScroll(el, options) {
        this.wrapper = typeof el == "string" ? document.querySelector(el) : el;
        this.scroller = this.wrapper.children[0];
        this.scrollerStyle = this.scroller.style; // cache style for better performance

        this.options = {
            zoomMin: 1,
            zoomMax: 4,
            startZoom: 1,

            resizeScrollbars: true,

            mouseWheelSpeed: 20,

            snapThreshold: 0.334,

            // INSERT POINT: OPTIONS

            startX: 0,
            startY: 0,
            scrollY: true,
            directionLockThreshold: 5,
            momentum: true,

            bounce: true,
            bounceTime: 600,
            bounceEasing: "",

            preventDefault: true,
            preventDefaultException: {
                tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/
            },

            HWCompositing: true,
            useTransition: true,
            useTransform: true
        };

        for (var i in options) {
            this.options[i] = options[i];
        }

        // Normalize options
        this.translateZ = this.options.HWCompositing && utils.hasPerspective ? " translateZ(0)" : "";

        this.options.useTransition = utils.hasTransition && this.options.useTransition;
        this.options.useTransform = utils.hasTransform && this.options.useTransform;

        this.options.eventPassthrough = this.options.eventPassthrough === true ? "vertical" : this.options.eventPassthrough;
        this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault;

        // If you want eventPassthrough I have to lock one of the axes
        this.options.scrollY = this.options.eventPassthrough == "vertical" ? false : this.options.scrollY;
        this.options.scrollX = this.options.eventPassthrough == "horizontal" ? false : this.options.scrollX;

        // With eventPassthrough we also need lockDirection mechanism
        this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough;
        this.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold;

        this.options.bounceEasing = typeof this.options.bounceEasing == "string" ? utils.ease[this.options.bounceEasing] || utils.ease.circular : this.options.bounceEasing;

        this.options.resizePolling = this.options.resizePolling === undefined ? 60 : this.options.resizePolling;

        if (this.options.tap === true) {
            this.options.tap = "tap";
        }

        if (this.options.shrinkScrollbars == "scale") {
            this.options.useTransition = false;
        }

        this.options.invertWheelDirection = this.options.invertWheelDirection ? -1 : 1;

        // INSERT POINT: NORMALIZATION

        // Some defaults
        this.x = 0;
        this.y = 0;
        this.directionX = 0;
        this.directionY = 0;
        this._events = {};

        this.scale = Math.min(Math.max(this.options.startZoom, this.options.zoomMin), this.options.zoomMax);

        // INSERT POINT: DEFAULTS

        this._init();
        this.refresh();

        this.scrollTo(this.options.startX, this.options.startY);
        this.enable();
    }

    IScroll.prototype = {
        version: "5.1.3",

        _init: function _init() {
            this._initEvents();

            if (this.options.zoom) {
                this._initZoom();
            }

            if (this.options.scrollbars || this.options.indicators) {
                this._initIndicators();
            }

            if (this.options.mouseWheel) {
                this._initWheel();
            }

            if (this.options.snap) {
                this._initSnap();
            }

            if (this.options.keyBindings) {
                this._initKeys();
            }

            // INSERT POINT: _init
        },

        destroy: function destroy() {
            this._initEvents(true);

            this._execEvent("destroy");
        },

        _transitionEnd: function _transitionEnd(e) {
            if (e.target != this.scroller || !this.isInTransition) {
                return;
            }

            this._transitionTime();
            if (!this.resetPosition(this.options.bounceTime)) {
                this.isInTransition = false;
                this._execEvent("scrollEnd");
            }
        },

        _start: function _start(e) {
            // React to left mouse button only
            if (utils.eventType[e.type] != 1) {
                if (e.button !== 0) {
                    return;
                }
            }

            if (!this.enabled || this.initiated && utils.eventType[e.type] !== this.initiated) {
                return;
            }

            if (this.options.preventDefault && !utils.isBadAndroid && !utils.preventDefaultException(e.target, this.options.preventDefaultException)) {
                e.preventDefault();
            }

            var point = e.touches ? e.touches[0] : e,
                pos;

            this.initiated = utils.eventType[e.type];
            this.moved = false;
            this.distX = 0;
            this.distY = 0;
            this.directionX = 0;
            this.directionY = 0;
            this.directionLocked = 0;

            this._transitionTime();

            this.startTime = utils.getTime();

            if (this.options.useTransition && this.isInTransition) {
                this.isInTransition = false;
                pos = this.getComputedPosition();
                this._translate(Math.round(pos.x), Math.round(pos.y));
                this._execEvent("scrollEnd");
            } else if (!this.options.useTransition && this.isAnimating) {
                this.isAnimating = false;
                this._execEvent("scrollEnd");
            }

            this.startX = this.x;
            this.startY = this.y;
            this.absStartX = this.x;
            this.absStartY = this.y;
            this.pointX = point.pageX;
            this.pointY = point.pageY;

            this._execEvent("beforeScrollStart");
        },

        _move: function _move(e) {
            if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
                return;
            }

            if (this.options.preventDefault) {
                // increases performance on Android? TODO: check!
                e.preventDefault();
            }

            var point = e.touches ? e.touches[0] : e,
                deltaX = point.pageX - this.pointX,
                deltaY = point.pageY - this.pointY,
                timestamp = utils.getTime(),
                newX,
                newY,
                absDistX,
                absDistY;

            this.pointX = point.pageX;
            this.pointY = point.pageY;

            this.distX += deltaX;
            this.distY += deltaY;
            absDistX = Math.abs(this.distX);
            absDistY = Math.abs(this.distY);

            // We need to move at least 10 pixels for the scrolling to initiate
            if (timestamp - this.endTime > 300 && absDistX < 10 && absDistY < 10) {
                return;
            }

            // If you are scrolling in one direction lock the other
            if (!this.directionLocked && !this.options.freeScroll) {
                if (absDistX > absDistY + this.options.directionLockThreshold) {
                    this.directionLocked = "h"; // lock horizontally
                } else if (absDistY >= absDistX + this.options.directionLockThreshold) {
                    this.directionLocked = "v"; // lock vertically
                } else {
                    this.directionLocked = "n"; // no lock
                }
            }

            if (this.directionLocked == "h") {
                if (this.options.eventPassthrough == "vertical") {
                    e.preventDefault();
                } else if (this.options.eventPassthrough == "horizontal") {
                    this.initiated = false;
                    return;
                }

                deltaY = 0;
            } else if (this.directionLocked == "v") {
                if (this.options.eventPassthrough == "horizontal") {
                    e.preventDefault();
                } else if (this.options.eventPassthrough == "vertical") {
                    this.initiated = false;
                    return;
                }

                deltaX = 0;
            }

            deltaX = this.hasHorizontalScroll ? deltaX : 0;
            deltaY = this.hasVerticalScroll ? deltaY : 0;

            newX = this.x + deltaX;
            newY = this.y + deltaY;

            // Slow down if outside of the boundaries
            if (newX > 0 || newX < this.maxScrollX) {
                newX = this.options.bounce ? this.x + deltaX / 3 : newX > 0 ? 0 : this.maxScrollX;
            }
            if (newY > 0 || newY < this.maxScrollY) {
                newY = this.options.bounce ? this.y + deltaY / 3 : newY > 0 ? 0 : this.maxScrollY;
            }

            this.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
            this.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;

            if (!this.moved) {
                this._execEvent("scrollStart");
            }

            this.moved = true;

            this._translate(newX, newY);

            /* REPLACE START: _move */

            if (timestamp - this.startTime > 300) {
                this.startTime = timestamp;
                this.startX = this.x;
                this.startY = this.y;
            }

            /* REPLACE END: _move */
        },

        _end: function _end(e) {
            if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
                return;
            }

            if (this.options.preventDefault && !utils.preventDefaultException(e.target, this.options.preventDefaultException)) {
                e.preventDefault();
            }

            var point = e.changedTouches ? e.changedTouches[0] : e,
                momentumX,
                momentumY,
                duration = utils.getTime() - this.startTime,
                newX = Math.round(this.x),
                newY = Math.round(this.y),
                distanceX = Math.abs(newX - this.startX),
                distanceY = Math.abs(newY - this.startY),
                time = 0,
                easing = "";

            this.isInTransition = 0;
            this.initiated = 0;
            this.endTime = utils.getTime();

            // reset if we are outside of the boundaries
            if (this.resetPosition(this.options.bounceTime)) {
                return;
            }

            this.scrollTo(newX, newY); // ensures that the last position is rounded

            // we scrolled less than 10 pixels
            if (!this.moved) {
                if (this.options.tap) {
                    utils.tap(e, this.options.tap);
                }

                if (this.options.click) {
                    utils.click(e);
                }

                this._execEvent("scrollCancel");
                return;
            }

            if (this._events.flick && duration < 200 && distanceX < 100 && distanceY < 100) {
                this._execEvent("flick");
                return;
            }

            // start momentum animation if needed
            if (this.options.momentum && duration < 300) {
                momentumX = this.hasHorizontalScroll ? utils.momentum(this.x, this.startX, duration, this.maxScrollX, this.options.bounce ? this.wrapperWidth : 0, this.options.deceleration) : { destination: newX, duration: 0 };
                momentumY = this.hasVerticalScroll ? utils.momentum(this.y, this.startY, duration, this.maxScrollY, this.options.bounce ? this.wrapperHeight : 0, this.options.deceleration) : { destination: newY, duration: 0 };
                newX = momentumX.destination;
                newY = momentumY.destination;
                time = Math.max(momentumX.duration, momentumY.duration);
                this.isInTransition = 1;
            }

            if (this.options.snap) {
                var snap = this._nearestSnap(newX, newY);
                this.currentPage = snap;
                time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(newX - snap.x), 1000), Math.min(Math.abs(newY - snap.y), 1000)), 300);
                newX = snap.x;
                newY = snap.y;

                this.directionX = 0;
                this.directionY = 0;
                easing = this.options.bounceEasing;
            }

            // INSERT POINT: _end

            if (newX != this.x || newY != this.y) {
                // change easing function when scroller goes out of the boundaries
                if (newX > 0 || newX < this.maxScrollX || newY > 0 || newY < this.maxScrollY) {
                    easing = utils.ease.quadratic;
                }

                this.scrollTo(newX, newY, time, easing);
                return;
            }

            this._execEvent("scrollEnd");
        },

        _resize: function _resize() {
            var that = this;

            clearTimeout(this.resizeTimeout);

            this.resizeTimeout = setTimeout(function () {
                that.refresh();
            }, this.options.resizePolling);
        },

        resetPosition: function resetPosition(time) {
            var x = this.x,
                y = this.y;

            time = time || 0;

            if (!this.hasHorizontalScroll || this.x > 0) {
                x = 0;
            } else if (this.x < this.maxScrollX) {
                x = this.maxScrollX;
            }

            if (!this.hasVerticalScroll || this.y > 0) {
                y = 0;
            } else if (this.y < this.maxScrollY) {
                y = this.maxScrollY;
            }

            if (x == this.x && y == this.y) {
                return false;
            }

            this.scrollTo(x, y, time, this.options.bounceEasing);

            return true;
        },

        disable: function disable() {
            this.enabled = false;
        },

        enable: function enable() {
            this.enabled = true;
        },

        refresh: function refresh() {
            var rf = this.wrapper.offsetHeight; // Force reflow

            this.wrapperWidth = this.wrapper.clientWidth;
            this.wrapperHeight = this.wrapper.clientHeight;

            /* REPLACE START: refresh */
            this.scrollerWidth = Math.round(this.scroller.offsetWidth * this.scale);
            this.scrollerHeight = Math.round(this.scroller.offsetHeight * this.scale);

            this.maxScrollX = this.wrapperWidth - this.scrollerWidth;
            this.maxScrollY = this.wrapperHeight - this.scrollerHeight;
            /* REPLACE END: refresh */

            this.hasHorizontalScroll = this.options.scrollX && this.maxScrollX < 0;
            this.hasVerticalScroll = this.options.scrollY && this.maxScrollY < 0;

            if (!this.hasHorizontalScroll) {
                this.maxScrollX = 0;
                this.scrollerWidth = this.wrapperWidth;
            }

            if (!this.hasVerticalScroll) {
                this.maxScrollY = 0;
                this.scrollerHeight = this.wrapperHeight;
            }

            this.endTime = 0;
            this.directionX = 0;
            this.directionY = 0;

            this.wrapperOffset = utils.offset(this.wrapper);

            this._execEvent("refresh");

            this.resetPosition();

            // INSERT POINT: _refresh
        },

        on: function on(type, fn) {
            if (!this._events[type]) {
                this._events[type] = [];
            }

            this._events[type].push(fn);
        },

        off: function off(type, fn) {
            if (!this._events[type]) {
                return;
            }

            var index = this._events[type].indexOf(fn);

            if (index > -1) {
                this._events[type].splice(index, 1);
            }
        },

        _execEvent: function _execEvent(type) {
            if (!this._events[type]) {
                return;
            }

            var i = 0,
                l = this._events[type].length;

            if (!l) {
                return;
            }

            for (; i < l; i++) {
                this._events[type][i].apply(this, [].slice.call(arguments, 1));
            }
        },

        scrollBy: function scrollBy(x, y, time, easing) {
            x = this.x + x;
            y = this.y + y;
            time = time || 0;

            this.scrollTo(x, y, time, easing);
        },

        scrollTo: function scrollTo(x, y, time, easing) {
            easing = easing || utils.ease.circular;

            this.isInTransition = this.options.useTransition && time > 0;

            if (!time || this.options.useTransition && easing.style) {
                this._transitionTimingFunction(easing.style);
                this._transitionTime(time);
                this._translate(x, y);
            } else {
                this._animate(x, y, time, easing.fn);
            }
        },

        scrollToElement: function scrollToElement(el, time, offsetX, offsetY, easing) {
            el = el.nodeType ? el : this.scroller.querySelector(el);

            if (!el) {
                return;
            }

            var pos = utils.offset(el);

            pos.left -= this.wrapperOffset.left;
            pos.top -= this.wrapperOffset.top;

            // if offsetX/Y are true we center the element to the screen
            if (offsetX === true) {
                offsetX = Math.round(el.offsetWidth / 2 - this.wrapper.offsetWidth / 2);
            }
            if (offsetY === true) {
                offsetY = Math.round(el.offsetHeight / 2 - this.wrapper.offsetHeight / 2);
            }

            pos.left -= offsetX || 0;
            pos.top -= offsetY || 0;

            pos.left = pos.left > 0 ? 0 : pos.left < this.maxScrollX ? this.maxScrollX : pos.left;
            pos.top = pos.top > 0 ? 0 : pos.top < this.maxScrollY ? this.maxScrollY : pos.top;

            time = time === undefined || time === null || time === "auto" ? Math.max(Math.abs(this.x - pos.left), Math.abs(this.y - pos.top)) : time;

            this.scrollTo(pos.left, pos.top, time, easing);
        },

        _transitionTime: function _transitionTime(time) {
            time = time || 0;

            this.scrollerStyle[utils.style.transitionDuration] = time + "ms";

            if (!time && utils.isBadAndroid) {
                this.scrollerStyle[utils.style.transitionDuration] = "0.001s";
            }

            if (this.indicators) {
                for (var i = this.indicators.length; i--;) {
                    this.indicators[i].transitionTime(time);
                }
            }

            // INSERT POINT: _transitionTime
        },

        _transitionTimingFunction: function _transitionTimingFunction(easing) {
            this.scrollerStyle[utils.style.transitionTimingFunction] = easing;

            if (this.indicators) {
                for (var i = this.indicators.length; i--;) {
                    this.indicators[i].transitionTimingFunction(easing);
                }
            }

            // INSERT POINT: _transitionTimingFunction
        },

        _translate: function _translate(x, y) {
            if (this.options.useTransform) {
                /* REPLACE START: _translate */this.scrollerStyle[utils.style.transform] = "translate(" + x + "px," + y + "px) scale(" + this.scale + ") " + this.translateZ; /* REPLACE END: _translate */
            } else {
                x = Math.round(x);
                y = Math.round(y);
                this.scrollerStyle.left = x + "px";
                this.scrollerStyle.top = y + "px";
            }

            this.x = x;
            this.y = y;

            if (this.indicators) {
                for (var i = this.indicators.length; i--;) {
                    this.indicators[i].updatePosition();
                }
            }

            // INSERT POINT: _translate
        },

        _initEvents: function _initEvents(remove) {
            var eventType = remove ? utils.removeEvent : utils.addEvent,
                target = this.options.bindToWrapper ? this.wrapper : window;

            eventType(window, "orientationchange", this);
            eventType(window, "resize", this);

            if (this.options.click) {
                eventType(this.wrapper, "click", this, true);
            }

            if (!this.options.disableMouse) {
                eventType(this.wrapper, "mousedown", this);
                eventType(target, "mousemove", this);
                eventType(target, "mousecancel", this);
                eventType(target, "mouseup", this);
            }

            if (utils.hasPointer && !this.options.disablePointer) {
                eventType(this.wrapper, utils.prefixPointerEvent("pointerdown"), this);
                eventType(target, utils.prefixPointerEvent("pointermove"), this);
                eventType(target, utils.prefixPointerEvent("pointercancel"), this);
                eventType(target, utils.prefixPointerEvent("pointerup"), this);
            }

            if (utils.hasTouch && !this.options.disableTouch) {
                eventType(this.wrapper, "touchstart", this);
                eventType(target, "touchmove", this);
                eventType(target, "touchcancel", this);
                eventType(target, "touchend", this);
            }

            eventType(this.scroller, "transitionend", this);
            eventType(this.scroller, "webkitTransitionEnd", this);
            eventType(this.scroller, "oTransitionEnd", this);
            eventType(this.scroller, "MSTransitionEnd", this);
        },

        getComputedPosition: function getComputedPosition() {
            var matrix = window.getComputedStyle(this.scroller, null),
                x,
                y;

            if (this.options.useTransform) {
                matrix = matrix[utils.style.transform].split(")")[0].split(", ");
                x = +(matrix[12] || matrix[4]);
                y = +(matrix[13] || matrix[5]);
            } else {
                x = +matrix.left.replace(/[^-\d.]/g, "");
                y = +matrix.top.replace(/[^-\d.]/g, "");
            }

            return { x: x, y: y };
        },

        _initIndicators: function _initIndicators() {
            var interactive = this.options.interactiveScrollbars,
                customStyle = typeof this.options.scrollbars != "string",
                indicators = [],
                indicator;

            var that = this;

            this.indicators = [];

            if (this.options.scrollbars) {
                // Vertical scrollbar
                if (this.options.scrollY) {
                    indicator = {
                        el: createDefaultScrollbar("v", interactive, this.options.scrollbars),
                        interactive: interactive,
                        defaultScrollbars: true,
                        customStyle: customStyle,
                        resize: this.options.resizeScrollbars,
                        shrink: this.options.shrinkScrollbars,
                        fade: this.options.fadeScrollbars,
                        listenX: false
                    };

                    this.wrapper.appendChild(indicator.el);
                    indicators.push(indicator);
                }

                // Horizontal scrollbar
                if (this.options.scrollX) {
                    indicator = {
                        el: createDefaultScrollbar("h", interactive, this.options.scrollbars),
                        interactive: interactive,
                        defaultScrollbars: true,
                        customStyle: customStyle,
                        resize: this.options.resizeScrollbars,
                        shrink: this.options.shrinkScrollbars,
                        fade: this.options.fadeScrollbars,
                        listenY: false
                    };

                    this.wrapper.appendChild(indicator.el);
                    indicators.push(indicator);
                }
            }

            if (this.options.indicators) {
                // TODO: check concat compatibility
                indicators = indicators.concat(this.options.indicators);
            }

            for (var i = indicators.length; i--;) {
                this.indicators.push(new Indicator(this, indicators[i]));
            }

            // TODO: check if we can use array.map (wide compatibility and performance issues)
            function _indicatorsMap(fn) {
                for (var i = that.indicators.length; i--;) {
                    fn.call(that.indicators[i]);
                }
            }

            if (this.options.fadeScrollbars) {
                this.on("scrollEnd", function () {
                    _indicatorsMap(function () {
                        this.fade();
                    });
                });

                this.on("scrollCancel", function () {
                    _indicatorsMap(function () {
                        this.fade();
                    });
                });

                this.on("scrollStart", function () {
                    _indicatorsMap(function () {
                        this.fade(1);
                    });
                });

                this.on("beforeScrollStart", function () {
                    _indicatorsMap(function () {
                        this.fade(1, true);
                    });
                });
            }

            this.on("refresh", function () {
                _indicatorsMap(function () {
                    this.refresh();
                });
            });

            this.on("destroy", function () {
                _indicatorsMap(function () {
                    this.destroy();
                });

                delete this.indicators;
            });
        },

        _initZoom: function _initZoom() {
            this.scrollerStyle[utils.style.transformOrigin] = "0 0";
        },

        _zoomStart: function _zoomStart(e) {
            var c1 = Math.abs(e.touches[0].pageX - e.touches[1].pageX),
                c2 = Math.abs(e.touches[0].pageY - e.touches[1].pageY);

            this.touchesDistanceStart = Math.sqrt(c1 * c1 + c2 * c2);
            this.startScale = this.scale;

            this.originX = Math.abs(e.touches[0].pageX + e.touches[1].pageX) / 2 + this.wrapperOffset.left - this.x;
            this.originY = Math.abs(e.touches[0].pageY + e.touches[1].pageY) / 2 + this.wrapperOffset.top - this.y;

            this._execEvent("zoomStart");
        },

        _zoom: function _zoom(e) {
            if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
                return;
            }

            if (this.options.preventDefault) {
                e.preventDefault();
            }

            var c1 = Math.abs(e.touches[0].pageX - e.touches[1].pageX),
                c2 = Math.abs(e.touches[0].pageY - e.touches[1].pageY),
                distance = Math.sqrt(c1 * c1 + c2 * c2),
                scale = 1 / this.touchesDistanceStart * distance * this.startScale,
                lastScale,
                x,
                y;

            this.scaled = true;

            if (scale < this.options.zoomMin) {
                scale = 0.5 * this.options.zoomMin * Math.pow(2.0, scale / this.options.zoomMin);
            } else if (scale > this.options.zoomMax) {
                scale = 2.0 * this.options.zoomMax * Math.pow(0.5, this.options.zoomMax / scale);
            }

            lastScale = scale / this.startScale;
            x = this.originX - this.originX * lastScale + this.startX;
            y = this.originY - this.originY * lastScale + this.startY;

            this.scale = scale;

            this.scrollTo(x, y, 0);
        },

        _zoomEnd: function _zoomEnd(e) {
            if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
                return;
            }

            if (this.options.preventDefault) {
                e.preventDefault();
            }

            var newX, newY, lastScale;

            this.isInTransition = 0;
            this.initiated = 0;

            if (this.scale > this.options.zoomMax) {
                this.scale = this.options.zoomMax;
            } else if (this.scale < this.options.zoomMin) {
                this.scale = this.options.zoomMin;
            }

            // Update boundaries
            this.refresh();

            lastScale = this.scale / this.startScale;

            newX = this.originX - this.originX * lastScale + this.startX;
            newY = this.originY - this.originY * lastScale + this.startY;

            if (newX > 0) {
                newX = 0;
            } else if (newX < this.maxScrollX) {
                newX = this.maxScrollX;
            }

            if (newY > 0) {
                newY = 0;
            } else if (newY < this.maxScrollY) {
                newY = this.maxScrollY;
            }

            if (this.x != newX || this.y != newY) {
                this.scrollTo(newX, newY, this.options.bounceTime);
            }

            this.scaled = false;

            this._execEvent("zoomEnd");
        },

        zoom: function zoom(scale, x, y, time) {
            if (scale < this.options.zoomMin) {
                scale = this.options.zoomMin;
            } else if (scale > this.options.zoomMax) {
                scale = this.options.zoomMax;
            }

            if (scale == this.scale) {
                return;
            }

            var relScale = scale / this.scale;

            x = x === undefined ? this.wrapperWidth / 2 : x;
            y = y === undefined ? this.wrapperHeight / 2 : y;
            time = time === undefined ? 300 : time;

            x = x + this.wrapperOffset.left - this.x;
            y = y + this.wrapperOffset.top - this.y;

            x = x - x * relScale + this.x;
            y = y - y * relScale + this.y;

            this.scale = scale;

            this.refresh(); // update boundaries

            if (x > 0) {
                x = 0;
            } else if (x < this.maxScrollX) {
                x = this.maxScrollX;
            }

            if (y > 0) {
                y = 0;
            } else if (y < this.maxScrollY) {
                y = this.maxScrollY;
            }

            this.scrollTo(x, y, time);
        },

        _wheelZoom: function _wheelZoom(e) {
            var wheelDeltaY,
                deltaScale,
                that = this;

            // Execute the zoomEnd event after 400ms the wheel stopped scrolling
            clearTimeout(this.wheelTimeout);
            this.wheelTimeout = setTimeout(function () {
                that._execEvent("zoomEnd");
            }, 400);

            if ("deltaX" in e) {
                wheelDeltaY = -e.deltaY / Math.abs(e.deltaY);
            } else if ("wheelDeltaX" in e) {
                wheelDeltaY = e.wheelDeltaY / Math.abs(e.wheelDeltaY);
            } else if ("wheelDelta" in e) {
                wheelDeltaY = e.wheelDelta / Math.abs(e.wheelDelta);
            } else if ("detail" in e) {
                wheelDeltaY = -e.detail / Math.abs(e.wheelDelta);
            } else {
                return;
            }

            deltaScale = this.scale + wheelDeltaY / 5;

            this.zoom(deltaScale, e.pageX, e.pageY, 0);
        },

        _initWheel: function _initWheel() {
            utils.addEvent(this.wrapper, "wheel", this);
            utils.addEvent(this.wrapper, "mousewheel", this);
            utils.addEvent(this.wrapper, "DOMMouseScroll", this);

            this.on("destroy", function () {
                utils.removeEvent(this.wrapper, "wheel", this);
                utils.removeEvent(this.wrapper, "mousewheel", this);
                utils.removeEvent(this.wrapper, "DOMMouseScroll", this);
            });
        },

        _wheel: function _wheel(e) {
            if (!this.enabled) {
                return;
            }

            e.preventDefault();
            e.stopPropagation();

            var wheelDeltaX,
                wheelDeltaY,
                newX,
                newY,
                that = this;

            if (this.wheelTimeout === undefined) {
                that._execEvent("scrollStart");
            }

            // Execute the scrollEnd event after 400ms the wheel stopped scrolling
            clearTimeout(this.wheelTimeout);
            this.wheelTimeout = setTimeout(function () {
                that._execEvent("scrollEnd");
                that.wheelTimeout = undefined;
            }, 400);

            if ("deltaX" in e) {
                if (e.deltaMode === 1) {
                    wheelDeltaX = -e.deltaX * this.options.mouseWheelSpeed;
                    wheelDeltaY = -e.deltaY * this.options.mouseWheelSpeed;
                } else {
                    wheelDeltaX = -e.deltaX;
                    wheelDeltaY = -e.deltaY;
                }
            } else if ("wheelDeltaX" in e) {
                wheelDeltaX = e.wheelDeltaX / 120 * this.options.mouseWheelSpeed;
                wheelDeltaY = e.wheelDeltaY / 120 * this.options.mouseWheelSpeed;
            } else if ("wheelDelta" in e) {
                wheelDeltaX = wheelDeltaY = e.wheelDelta / 120 * this.options.mouseWheelSpeed;
            } else if ("detail" in e) {
                wheelDeltaX = wheelDeltaY = -e.detail / 3 * this.options.mouseWheelSpeed;
            } else {
                return;
            }

            wheelDeltaX *= this.options.invertWheelDirection;
            wheelDeltaY *= this.options.invertWheelDirection;

            if (!this.hasVerticalScroll) {
                wheelDeltaX = wheelDeltaY;
                wheelDeltaY = 0;
            }

            if (this.options.snap) {
                newX = this.currentPage.pageX;
                newY = this.currentPage.pageY;

                if (wheelDeltaX > 0) {
                    newX--;
                } else if (wheelDeltaX < 0) {
                    newX++;
                }

                if (wheelDeltaY > 0) {
                    newY--;
                } else if (wheelDeltaY < 0) {
                    newY++;
                }

                this.goToPage(newX, newY);

                return;
            }

            newX = this.x + Math.round(this.hasHorizontalScroll ? wheelDeltaX : 0);
            newY = this.y + Math.round(this.hasVerticalScroll ? wheelDeltaY : 0);

            if (newX > 0) {
                newX = 0;
            } else if (newX < this.maxScrollX) {
                newX = this.maxScrollX;
            }

            if (newY > 0) {
                newY = 0;
            } else if (newY < this.maxScrollY) {
                newY = this.maxScrollY;
            }

            this.scrollTo(newX, newY, 0);

            // INSERT POINT: _wheel
        },

        _initSnap: function _initSnap() {
            this.currentPage = {};

            if (typeof this.options.snap == "string") {
                this.options.snap = this.scroller.querySelectorAll(this.options.snap);
            }

            this.on("refresh", function () {
                var i = 0,
                    l,
                    m = 0,
                    n,
                    cx,
                    cy,
                    x = 0,
                    y,
                    stepX = this.options.snapStepX || this.wrapperWidth,
                    stepY = this.options.snapStepY || this.wrapperHeight,
                    el;

                this.pages = [];

                if (!this.wrapperWidth || !this.wrapperHeight || !this.scrollerWidth || !this.scrollerHeight) {
                    return;
                }

                if (this.options.snap === true) {
                    cx = Math.round(stepX / 2);
                    cy = Math.round(stepY / 2);

                    while (x > -this.scrollerWidth) {
                        this.pages[i] = [];
                        l = 0;
                        y = 0;

                        while (y > -this.scrollerHeight) {
                            this.pages[i][l] = {
                                x: Math.max(x, this.maxScrollX),
                                y: Math.max(y, this.maxScrollY),
                                width: stepX,
                                height: stepY,
                                cx: x - cx,
                                cy: y - cy
                            };

                            y -= stepY;
                            l++;
                        }

                        x -= stepX;
                        i++;
                    }
                } else {
                    el = this.options.snap;
                    l = el.length;
                    n = -1;

                    for (; i < l; i++) {
                        if (i === 0 || el[i].offsetLeft <= el[i - 1].offsetLeft) {
                            m = 0;
                            n++;
                        }

                        if (!this.pages[m]) {
                            this.pages[m] = [];
                        }

                        x = Math.max(-el[i].offsetLeft, this.maxScrollX);
                        y = Math.max(-el[i].offsetTop, this.maxScrollY);
                        cx = x - Math.round(el[i].offsetWidth / 2);
                        cy = y - Math.round(el[i].offsetHeight / 2);

                        this.pages[m][n] = {
                            x: x,
                            y: y,
                            width: el[i].offsetWidth,
                            height: el[i].offsetHeight,
                            cx: cx,
                            cy: cy
                        };

                        if (x > this.maxScrollX) {
                            m++;
                        }
                    }
                }

                this.goToPage(this.currentPage.pageX || 0, this.currentPage.pageY || 0, 0);

                // Update snap threshold if needed
                if (this.options.snapThreshold % 1 === 0) {
                    this.snapThresholdX = this.options.snapThreshold;
                    this.snapThresholdY = this.options.snapThreshold;
                } else {
                    this.snapThresholdX = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].width * this.options.snapThreshold);
                    this.snapThresholdY = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].height * this.options.snapThreshold);
                }
            });

            this.on("flick", function () {
                var time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(this.x - this.startX), 1000), Math.min(Math.abs(this.y - this.startY), 1000)), 300);

                this.goToPage(this.currentPage.pageX + this.directionX, this.currentPage.pageY + this.directionY, time);
            });
        },

        _nearestSnap: function _nearestSnap(x, y) {
            if (!this.pages.length) {
                return { x: 0, y: 0, pageX: 0, pageY: 0 };
            }

            var i = 0,
                l = this.pages.length,
                m = 0;

            // Check if we exceeded the snap threshold
            if (Math.abs(x - this.absStartX) < this.snapThresholdX && Math.abs(y - this.absStartY) < this.snapThresholdY) {
                return this.currentPage;
            }

            if (x > 0) {
                x = 0;
            } else if (x < this.maxScrollX) {
                x = this.maxScrollX;
            }

            if (y > 0) {
                y = 0;
            } else if (y < this.maxScrollY) {
                y = this.maxScrollY;
            }

            for (; i < l; i++) {
                if (x >= this.pages[i][0].cx) {
                    x = this.pages[i][0].x;
                    break;
                }
            }

            l = this.pages[i].length;

            for (; m < l; m++) {
                if (y >= this.pages[0][m].cy) {
                    y = this.pages[0][m].y;
                    break;
                }
            }

            if (i == this.currentPage.pageX) {
                i += this.directionX;

                if (i < 0) {
                    i = 0;
                } else if (i >= this.pages.length) {
                    i = this.pages.length - 1;
                }

                x = this.pages[i][0].x;
            }

            if (m == this.currentPage.pageY) {
                m += this.directionY;

                if (m < 0) {
                    m = 0;
                } else if (m >= this.pages[0].length) {
                    m = this.pages[0].length - 1;
                }

                y = this.pages[0][m].y;
            }

            return {
                x: x,
                y: y,
                pageX: i,
                pageY: m
            };
        },

        goToPage: function goToPage(x, y, time, easing) {
            easing = easing || this.options.bounceEasing;

            if (x >= this.pages.length) {
                x = this.pages.length - 1;
            } else if (x < 0) {
                x = 0;
            }

            if (y >= this.pages[x].length) {
                y = this.pages[x].length - 1;
            } else if (y < 0) {
                y = 0;
            }

            var posX = this.pages[x][y].x,
                posY = this.pages[x][y].y;

            time = time === undefined ? this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(posX - this.x), 1000), Math.min(Math.abs(posY - this.y), 1000)), 300) : time;

            this.currentPage = {
                x: posX,
                y: posY,
                pageX: x,
                pageY: y
            };

            this.scrollTo(posX, posY, time, easing);
        },

        next: function next(time, easing) {
            var x = this.currentPage.pageX,
                y = this.currentPage.pageY;

            x++;

            if (x >= this.pages.length && this.hasVerticalScroll) {
                x = 0;
                y++;
            }

            this.goToPage(x, y, time, easing);
        },

        prev: function prev(time, easing) {
            var x = this.currentPage.pageX,
                y = this.currentPage.pageY;

            x--;

            if (x < 0 && this.hasVerticalScroll) {
                x = 0;
                y--;
            }

            this.goToPage(x, y, time, easing);
        },

        _initKeys: function _initKeys(e) {
            // default key bindings
            var keys = {
                pageUp: 33,
                pageDown: 34,
                end: 35,
                home: 36,
                left: 37,
                up: 38,
                right: 39,
                down: 40
            };
            var i;

            // if you give me characters I give you keycode
            if (_typeof(this.options.keyBindings) == "object") {
                for (i in this.options.keyBindings) {
                    if (typeof this.options.keyBindings[i] == "string") {
                        this.options.keyBindings[i] = this.options.keyBindings[i].toUpperCase().charCodeAt(0);
                    }
                }
            } else {
                this.options.keyBindings = {};
            }

            for (i in keys) {
                this.options.keyBindings[i] = this.options.keyBindings[i] || keys[i];
            }

            utils.addEvent(window, "keydown", this);

            this.on("destroy", function () {
                utils.removeEvent(window, "keydown", this);
            });
        },

        _key: function _key(e) {
            if (!this.enabled) {
                return;
            }

            var snap = this.options.snap,
                // we are using this alot, better to cache it
            newX = snap ? this.currentPage.pageX : this.x,
                newY = snap ? this.currentPage.pageY : this.y,
                now = utils.getTime(),
                prevTime = this.keyTime || 0,
                acceleration = 0.25,
                pos;

            if (this.options.useTransition && this.isInTransition) {
                pos = this.getComputedPosition();

                this._translate(Math.round(pos.x), Math.round(pos.y));
                this.isInTransition = false;
            }

            this.keyAcceleration = now - prevTime < 200 ? Math.min(this.keyAcceleration + acceleration, 50) : 0;

            switch (e.keyCode) {
                case this.options.keyBindings.pageUp:
                    if (this.hasHorizontalScroll && !this.hasVerticalScroll) {
                        newX += snap ? 1 : this.wrapperWidth;
                    } else {
                        newY += snap ? 1 : this.wrapperHeight;
                    }
                    break;
                case this.options.keyBindings.pageDown:
                    if (this.hasHorizontalScroll && !this.hasVerticalScroll) {
                        newX -= snap ? 1 : this.wrapperWidth;
                    } else {
                        newY -= snap ? 1 : this.wrapperHeight;
                    }
                    break;
                case this.options.keyBindings.end:
                    newX = snap ? this.pages.length - 1 : this.maxScrollX;
                    newY = snap ? this.pages[0].length - 1 : this.maxScrollY;
                    break;
                case this.options.keyBindings.home:
                    newX = 0;
                    newY = 0;
                    break;
                case this.options.keyBindings.left:
                    newX += snap ? -1 : 5 + this.keyAcceleration >> 0;
                    break;
                case this.options.keyBindings.up:
                    newY += snap ? 1 : 5 + this.keyAcceleration >> 0;
                    break;
                case this.options.keyBindings.right:
                    newX -= snap ? -1 : 5 + this.keyAcceleration >> 0;
                    break;
                case this.options.keyBindings.down:
                    newY -= snap ? 1 : 5 + this.keyAcceleration >> 0;
                    break;
                default:
                    return;
            }

            if (snap) {
                this.goToPage(newX, newY);
                return;
            }

            if (newX > 0) {
                newX = 0;
                this.keyAcceleration = 0;
            } else if (newX < this.maxScrollX) {
                newX = this.maxScrollX;
                this.keyAcceleration = 0;
            }

            if (newY > 0) {
                newY = 0;
                this.keyAcceleration = 0;
            } else if (newY < this.maxScrollY) {
                newY = this.maxScrollY;
                this.keyAcceleration = 0;
            }

            this.scrollTo(newX, newY, 0);

            this.keyTime = now;
        },

        _animate: function _animate(destX, destY, duration, easingFn) {
            var that = this,
                startX = this.x,
                startY = this.y,
                startTime = utils.getTime(),
                destTime = startTime + duration;

            function step() {
                var now = utils.getTime(),
                    newX,
                    newY,
                    easing;

                if (now >= destTime) {
                    that.isAnimating = false;
                    that._translate(destX, destY);

                    if (!that.resetPosition(that.options.bounceTime)) {
                        that._execEvent("scrollEnd");
                    }

                    return;
                }

                now = (now - startTime) / duration;
                easing = easingFn(now);
                newX = (destX - startX) * easing + startX;
                newY = (destY - startY) * easing + startY;
                that._translate(newX, newY);

                if (that.isAnimating) {
                    rAF(step);
                }
            }

            this.isAnimating = true;
            step();
        },
        handleEvent: function handleEvent(e) {
            switch (e.type) {
                case "touchstart":
                case "pointerdown":
                case "MSPointerDown":
                case "mousedown":
                    this._start(e);

                    if (this.options.zoom && e.touches && e.touches.length > 1) {
                        this._zoomStart(e);
                    }
                    break;
                case "touchmove":
                case "pointermove":
                case "MSPointerMove":
                case "mousemove":
                    if (this.options.zoom && e.touches && e.touches[1]) {
                        this._zoom(e);
                        return;
                    }
                    this._move(e);
                    break;
                case "touchend":
                case "pointerup":
                case "MSPointerUp":
                case "mouseup":
                case "touchcancel":
                case "pointercancel":
                case "MSPointerCancel":
                case "mousecancel":
                    if (this.scaled) {
                        this._zoomEnd(e);
                        return;
                    }
                    this._end(e);
                    break;
                case "orientationchange":
                case "resize":
                    this._resize();
                    break;
                case "transitionend":
                case "webkitTransitionEnd":
                case "oTransitionEnd":
                case "MSTransitionEnd":
                    this._transitionEnd(e);
                    break;
                case "wheel":
                case "DOMMouseScroll":
                case "mousewheel":
                    if (this.options.wheelAction == "zoom") {
                        this._wheelZoom(e);
                        return;
                    }
                    this._wheel(e);
                    break;
                case "keydown":
                    this._key(e);
                    break;
            }
        }
    };
    function createDefaultScrollbar(direction, interactive, type) {
        var scrollbar = document.createElement("div"),
            indicator = document.createElement("div");

        if (type === true) {
            scrollbar.style.cssText = "position:absolute;z-index:9999";
            indicator.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px";
        }

        indicator.className = "iScrollIndicator";

        if (direction == "h") {
            if (type === true) {
                scrollbar.style.cssText += ";height:7px;left:2px;right:2px;bottom:0";
                indicator.style.height = "100%";
            }
            scrollbar.className = "iScrollHorizontalScrollbar";
        } else {
            if (type === true) {
                scrollbar.style.cssText += ";width:7px;bottom:2px;top:2px;right:1px";
                indicator.style.width = "100%";
            }
            scrollbar.className = "iScrollVerticalScrollbar";
        }

        scrollbar.style.cssText += ";overflow:hidden";

        if (!interactive) {
            scrollbar.style.pointerEvents = "none";
        }

        scrollbar.appendChild(indicator);

        return scrollbar;
    }

    function Indicator(scroller, options) {
        this.wrapper = typeof options.el == "string" ? document.querySelector(options.el) : options.el;
        this.wrapperStyle = this.wrapper.style;
        this.indicator = this.wrapper.children[0];
        this.indicatorStyle = this.indicator.style;
        this.scroller = scroller;

        this.options = {
            listenX: true,
            listenY: true,
            interactive: false,
            resize: true,
            defaultScrollbars: false,
            shrink: false,
            fade: false,
            speedRatioX: 0,
            speedRatioY: 0
        };

        for (var i in options) {
            this.options[i] = options[i];
        }

        this.sizeRatioX = 1;
        this.sizeRatioY = 1;
        this.maxPosX = 0;
        this.maxPosY = 0;

        if (this.options.interactive) {
            if (!this.options.disableTouch) {
                utils.addEvent(this.indicator, "touchstart", this);
                utils.addEvent(window, "touchend", this);
            }
            if (!this.options.disablePointer) {
                utils.addEvent(this.indicator, utils.prefixPointerEvent("pointerdown"), this);
                utils.addEvent(window, utils.prefixPointerEvent("pointerup"), this);
            }
            if (!this.options.disableMouse) {
                utils.addEvent(this.indicator, "mousedown", this);
                utils.addEvent(window, "mouseup", this);
            }
        }

        if (this.options.fade) {
            this.wrapperStyle[utils.style.transform] = this.scroller.translateZ;
            this.wrapperStyle[utils.style.transitionDuration] = utils.isBadAndroid ? "0.001s" : "0ms";
            this.wrapperStyle.opacity = "0";
        }
    }

    Indicator.prototype = {
        handleEvent: function handleEvent(e) {
            switch (e.type) {
                case "touchstart":
                case "pointerdown":
                case "MSPointerDown":
                case "mousedown":
                    this._start(e);
                    break;
                case "touchmove":
                case "pointermove":
                case "MSPointerMove":
                case "mousemove":
                    this._move(e);
                    break;
                case "touchend":
                case "pointerup":
                case "MSPointerUp":
                case "mouseup":
                case "touchcancel":
                case "pointercancel":
                case "MSPointerCancel":
                case "mousecancel":
                    this._end(e);
                    break;
            }
        },

        destroy: function destroy() {
            if (this.options.interactive) {
                utils.removeEvent(this.indicator, "touchstart", this);
                utils.removeEvent(this.indicator, utils.prefixPointerEvent("pointerdown"), this);
                utils.removeEvent(this.indicator, "mousedown", this);

                utils.removeEvent(window, "touchmove", this);
                utils.removeEvent(window, utils.prefixPointerEvent("pointermove"), this);
                utils.removeEvent(window, "mousemove", this);

                utils.removeEvent(window, "touchend", this);
                utils.removeEvent(window, utils.prefixPointerEvent("pointerup"), this);
                utils.removeEvent(window, "mouseup", this);
            }

            if (this.options.defaultScrollbars) {
                this.wrapper.parentNode.removeChild(this.wrapper);
            }
        },

        _start: function _start(e) {
            var point = e.touches ? e.touches[0] : e;

            e.preventDefault();
            e.stopPropagation();

            this.transitionTime();

            this.initiated = true;
            this.moved = false;
            this.lastPointX = point.pageX;
            this.lastPointY = point.pageY;

            this.startTime = utils.getTime();

            if (!this.options.disableTouch) {
                utils.addEvent(window, "touchmove", this);
            }
            if (!this.options.disablePointer) {
                utils.addEvent(window, utils.prefixPointerEvent("pointermove"), this);
            }
            if (!this.options.disableMouse) {
                utils.addEvent(window, "mousemove", this);
            }

            this.scroller._execEvent("beforeScrollStart");
        },

        _move: function _move(e) {
            var point = e.touches ? e.touches[0] : e,
                deltaX,
                deltaY,
                newX,
                newY,
                timestamp = utils.getTime();

            if (!this.moved) {
                this.scroller._execEvent("scrollStart");
            }

            this.moved = true;

            deltaX = point.pageX - this.lastPointX;
            this.lastPointX = point.pageX;

            deltaY = point.pageY - this.lastPointY;
            this.lastPointY = point.pageY;

            newX = this.x + deltaX;
            newY = this.y + deltaY;

            this._pos(newX, newY);

            // INSERT POINT: indicator._move

            e.preventDefault();
            e.stopPropagation();
        },

        _end: function _end(e) {
            if (!this.initiated) {
                return;
            }

            this.initiated = false;

            e.preventDefault();
            e.stopPropagation();

            utils.removeEvent(window, "touchmove", this);
            utils.removeEvent(window, utils.prefixPointerEvent("pointermove"), this);
            utils.removeEvent(window, "mousemove", this);

            if (this.scroller.options.snap) {
                var snap = this.scroller._nearestSnap(this.scroller.x, this.scroller.y);

                var time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(this.scroller.x - snap.x), 1000), Math.min(Math.abs(this.scroller.y - snap.y), 1000)), 300);

                if (this.scroller.x != snap.x || this.scroller.y != snap.y) {
                    this.scroller.directionX = 0;
                    this.scroller.directionY = 0;
                    this.scroller.currentPage = snap;
                    this.scroller.scrollTo(snap.x, snap.y, time, this.scroller.options.bounceEasing);
                }
            }

            if (this.moved) {
                this.scroller._execEvent("scrollEnd");
            }
        },

        transitionTime: function transitionTime(time) {
            time = time || 0;
            this.indicatorStyle[utils.style.transitionDuration] = time + "ms";

            if (!time && utils.isBadAndroid) {
                this.indicatorStyle[utils.style.transitionDuration] = "0.001s";
            }
        },

        transitionTimingFunction: function transitionTimingFunction(easing) {
            this.indicatorStyle[utils.style.transitionTimingFunction] = easing;
        },

        refresh: function refresh() {
            this.transitionTime();

            if (this.options.listenX && !this.options.listenY) {
                this.indicatorStyle.display = this.scroller.hasHorizontalScroll ? "block" : "none";
            } else if (this.options.listenY && !this.options.listenX) {
                this.indicatorStyle.display = this.scroller.hasVerticalScroll ? "block" : "none";
            } else {
                this.indicatorStyle.display = this.scroller.hasHorizontalScroll || this.scroller.hasVerticalScroll ? "block" : "none";
            }

            if (this.scroller.hasHorizontalScroll && this.scroller.hasVerticalScroll) {
                utils.addClass(this.wrapper, "iScrollBothScrollbars");
                utils.removeClass(this.wrapper, "iScrollLoneScrollbar");

                if (this.options.defaultScrollbars && this.options.customStyle) {
                    if (this.options.listenX) {
                        this.wrapper.style.right = "8px";
                    } else {
                        this.wrapper.style.bottom = "8px";
                    }
                }
            } else {
                utils.removeClass(this.wrapper, "iScrollBothScrollbars");
                utils.addClass(this.wrapper, "iScrollLoneScrollbar");

                if (this.options.defaultScrollbars && this.options.customStyle) {
                    if (this.options.listenX) {
                        this.wrapper.style.right = "2px";
                    } else {
                        this.wrapper.style.bottom = "2px";
                    }
                }
            }

            var r = this.wrapper.offsetHeight; // force refresh

            if (this.options.listenX) {
                this.wrapperWidth = this.wrapper.clientWidth;
                if (this.options.resize) {
                    this.indicatorWidth = Math.max(Math.round(this.wrapperWidth * this.wrapperWidth / (this.scroller.scrollerWidth || this.wrapperWidth || 1)), 8);
                    this.indicatorStyle.width = this.indicatorWidth + "px";
                } else {
                    this.indicatorWidth = this.indicator.clientWidth;
                }

                this.maxPosX = this.wrapperWidth - this.indicatorWidth;

                if (this.options.shrink == "clip") {
                    this.minBoundaryX = -this.indicatorWidth + 8;
                    this.maxBoundaryX = this.wrapperWidth - 8;
                } else {
                    this.minBoundaryX = 0;
                    this.maxBoundaryX = this.maxPosX;
                }

                this.sizeRatioX = this.options.speedRatioX || this.scroller.maxScrollX && this.maxPosX / this.scroller.maxScrollX;
            }

            if (this.options.listenY) {
                this.wrapperHeight = this.wrapper.clientHeight;
                if (this.options.resize) {
                    this.indicatorHeight = Math.max(Math.round(this.wrapperHeight * this.wrapperHeight / (this.scroller.scrollerHeight || this.wrapperHeight || 1)), 8);
                    this.indicatorStyle.height = this.indicatorHeight + "px";
                } else {
                    this.indicatorHeight = this.indicator.clientHeight;
                }

                this.maxPosY = this.wrapperHeight - this.indicatorHeight;

                if (this.options.shrink == "clip") {
                    this.minBoundaryY = -this.indicatorHeight + 8;
                    this.maxBoundaryY = this.wrapperHeight - 8;
                } else {
                    this.minBoundaryY = 0;
                    this.maxBoundaryY = this.maxPosY;
                }

                this.maxPosY = this.wrapperHeight - this.indicatorHeight;
                this.sizeRatioY = this.options.speedRatioY || this.scroller.maxScrollY && this.maxPosY / this.scroller.maxScrollY;
            }

            this.updatePosition();
        },

        updatePosition: function updatePosition() {
            var x = this.options.listenX && Math.round(this.sizeRatioX * this.scroller.x) || 0,
                y = this.options.listenY && Math.round(this.sizeRatioY * this.scroller.y) || 0;

            if (!this.options.ignoreBoundaries) {
                if (x < this.minBoundaryX) {
                    if (this.options.shrink == "scale") {
                        this.width = Math.max(this.indicatorWidth + x, 8);
                        this.indicatorStyle.width = this.width + "px";
                    }
                    x = this.minBoundaryX;
                } else if (x > this.maxBoundaryX) {
                    if (this.options.shrink == "scale") {
                        this.width = Math.max(this.indicatorWidth - (x - this.maxPosX), 8);
                        this.indicatorStyle.width = this.width + "px";
                        x = this.maxPosX + this.indicatorWidth - this.width;
                    } else {
                        x = this.maxBoundaryX;
                    }
                } else if (this.options.shrink == "scale" && this.width != this.indicatorWidth) {
                    this.width = this.indicatorWidth;
                    this.indicatorStyle.width = this.width + "px";
                }

                if (y < this.minBoundaryY) {
                    if (this.options.shrink == "scale") {
                        this.height = Math.max(this.indicatorHeight + y * 3, 8);
                        this.indicatorStyle.height = this.height + "px";
                    }
                    y = this.minBoundaryY;
                } else if (y > this.maxBoundaryY) {
                    if (this.options.shrink == "scale") {
                        this.height = Math.max(this.indicatorHeight - (y - this.maxPosY) * 3, 8);
                        this.indicatorStyle.height = this.height + "px";
                        y = this.maxPosY + this.indicatorHeight - this.height;
                    } else {
                        y = this.maxBoundaryY;
                    }
                } else if (this.options.shrink == "scale" && this.height != this.indicatorHeight) {
                    this.height = this.indicatorHeight;
                    this.indicatorStyle.height = this.height + "px";
                }
            }

            this.x = x;
            this.y = y;

            if (this.scroller.options.useTransform) {
                this.indicatorStyle[utils.style.transform] = "translate(" + x + "px," + y + "px)" + this.scroller.translateZ;
            } else {
                this.indicatorStyle.left = x + "px";
                this.indicatorStyle.top = y + "px";
            }
        },

        _pos: function _pos(x, y) {
            if (x < 0) {
                x = 0;
            } else if (x > this.maxPosX) {
                x = this.maxPosX;
            }

            if (y < 0) {
                y = 0;
            } else if (y > this.maxPosY) {
                y = this.maxPosY;
            }

            x = this.options.listenX ? Math.round(x / this.sizeRatioX) : this.scroller.x;
            y = this.options.listenY ? Math.round(y / this.sizeRatioY) : this.scroller.y;

            this.scroller.scrollTo(x, y);
        },

        fade: function fade(val, hold) {
            if (hold && !this.visible) {
                return;
            }

            clearTimeout(this.fadeTimeout);
            this.fadeTimeout = null;

            var time = val ? 250 : 500,
                delay = val ? 0 : 300;

            val = val ? "1" : "0";

            this.wrapperStyle[utils.style.transitionDuration] = time + "ms";

            this.fadeTimeout = setTimeout(function (val) {
                this.wrapperStyle.opacity = val;
                this.visible = +val;
            }.bind(this, val), delay);
        }
    };

    IScroll.utils = utils;

    if (typeof module != "undefined" && module.exports) {
        module.exports = IScroll;
    } else {
        window.IScroll = IScroll;
    }
})(window, document, Math);

/***/ }),

/***/ "Ib5e":
/***/ (function(module, exports, __webpack_require__) {

var $imports = __webpack_require__("+ObC");
module.exports = function ($data) {
    'use strict';
    $data = $data || {};
    var $$out = '';
    $$out += '<div class="blocks-footer">\r\n    <div class="inner">\r\n        <a href="http://ieg.tencent.com" target="_blank" class="logo-ieg" title="腾讯互动娱乐"><span class="alt-txt">腾讯互动娱乐</span></a>\r\n        <p class="links"><a href="http://ieg.tencent.com" target="_blank">腾讯互动娱乐</a> | <a href="http://game.qq.com/contract.shtml" target="_blank">服务条款</a> | <a href="http://www.tencentmind.com" target="_blank">广告服务</a> | <a href="http://game.qq.com/hr/" target="_blank">腾讯游戏招聘</a> | <a href="http://service.qq.com/" target="_blank">腾讯游戏客服</a> | <a href="http://game.qq.com/gnav" target="_blank">游戏地图</a> | <a href="http://tgact.qq.com/" target="_blank">游戏活动</a> | <a href="http://game.qq.com/brand/business.htm" target="_blank">商务合作</a> | <a href="http://www.qq.com/map/" target="_blank">网站导航</a></p>\r\n        <p class="copyright">COPYRIGHT &copy; 1998 \u2013 2019 TENCENT. ALL RIGHTS RESERVED. <a target="_blank" href="http://www.tencent.com/law/mo_law.shtml?/law/copyright.htm">腾讯公司 版权所有</a></p>\r\n    </div>\r\n</div>';
    return $$out;
};

/***/ }),

/***/ "KPmn":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "KUwY":
/***/ (function(module, exports, __webpack_require__) {

var $imports = __webpack_require__("+ObC");
module.exports = function ($data) {
    'use strict';
    $data = $data || {};
    var $$out = '', $escape = $imports.$escape, zwmc_8b = $data.zwmc_8b, ssztq_05 = $data.ssztq_05, jj_e7 = $data.jj_e7, hasExp = $data.hasExp, tyd_dc = $data.tyd_dc, $each = $imports.$each, item = $data.item, index = $data.index;
    $$out += '<h2 class="title">';
    $$out += $escape(zwmc_8b);
    $$out += '</h2>\r\n<div class="btn-close"></div>\r\n<div class="text-content-wrapper">\r\n    ';
    if (ssztq_05) {
        $$out += '\r\n    <p class="desc">';
        $$out += $escape(jj_e7);
        $$out += '</p>\r\n    ';
    }
    $$out += '\r\n    ';
    var hasExp = tyd_dc && tyd_dc.length;
    $$out += '\r\n    <div class="experiences">\r\n        ';
    if (hasExp && tyd_dc.length > 1) {
        $$out += '\r\n        <div class="btn-nav btn-nav-prev"></div>\r\n        ';
    }
    $$out += '\r\n        ';
    if (hasExp) {
        $$out += '\r\n        <div class="swiper-container">\r\n            <div class="swiper-wrapper">\r\n                ';
        $each(tyd_dc, function (item, index) {
            $$out += '\r\n                <div class="swiper-slide">\r\n                    <h4 class="experience-title">';
            $$out += $escape(item.zwmc_8b);
            $$out += '</h4>\r\n                    <div class="experience-desc">';
            $$out += item.jj_e7;
            $$out += '</div>\r\n                </div>\r\n                ';
        });
        $$out += '\r\n            </div>\r\n        </div>\r\n        ';
    }
    $$out += '\r\n        ';
    if (hasExp && tyd_dc.length > 1) {
        $$out += '\r\n        <div class="btn-nav btn-nav-next"></div>\r\n        ';
    }
    $$out += '\r\n    </div>\r\n</div>';
    return $$out;
};

/***/ }),

/***/ "Ow/d":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "//game.gtimg.cn/images/game/act/a20181206tgc/img/map-pc.ebdd977.jpg";

/***/ }),

/***/ "Rnay":
/***/ (function(module, exports, __webpack_require__) {

var $imports = __webpack_require__("+ObC");
module.exports = function ($data) {
    'use strict';
    $data = $data || {};
    var $$out = '', $escape = $imports.$escape, qrcode = $data.qrcode;
    $$out += '<div class="float-qrcode">\r\n    <div class="qrcode-lp">\r\n        <div class="qrcode-float"><img src="';
    $$out += $escape(qrcode);
    $$out += '" alt=""></div>\r\n    </div>\r\n   ';
    // $$out += ' <a href="/2019/living.html" class="living-entrance"></a>\r\n    <div class="ticket-entrance"></div>\r\n</div> ';
    return $$out;
};

/***/ }),

/***/ "UElg":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("YPio");

var _index = __webpack_require__("DyQB");

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = function (uniq, options) {
    var $container = $("" + uniq);
    var data = options.data;


    var cur = getCurTabFromUrl();
    data.cur = cur;
    render(data);
    bindEvent();

    function render(data) {
        var html = (0, _index2.default)(data);
        $container.html(html);
    }

    function bindEvent() {
        $container.on("click", ".tabs li", onTabClick);
    }

    function onTabClick(ev) {
        var $el = $(ev.currentTarget);
        var index = $el.index();
        // 改变当前tab
        $el.addClass("on").siblings().removeClass("on");
        // 显示对应的tab内容
        var $tabContent = $($container.find(".content-wrapper .tab-content").get(index));
        $tabContent.addClass("on").siblings().removeClass("on");
    }

    function getCurTabFromUrl() {
        var hash = location.hash;
        var cur = data.tabs[0].key; // 默认为第一个tab

        if (!hash) {
            return cur;
        }

        var match = data.tabs.findIndex(function (tab) {
            return hash.includes(tab.key);
        });
        if (match > -1) {
            cur = data.tabs[match].key;
        }
        return cur;
    }
};

/***/ }),

/***/ "X6PD":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getScriptFx;
/**
 * @file zepto的getScript polyfill
 *   zepto本身没有getScript方法，但使用v4接口都是script数据，用getScript方法便于获取数据
 */

function getScriptFx($) {
    if (!$.getScript || typeof $.getScript === "function") {
        $.getScript = function (src, func) {
            var script = document.createElement("script");
            script.async = "async";
            script.src = src;
            if (func) {
                script.onload = func;
            }
            document.getElementsByTagName("head")[0].appendChild(script);
        };
    }
}

/***/ }),

/***/ "Y4eA":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "YPio":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "ZmHP":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "//game.gtimg.cn/images/game/act/a20181206tgc/img/logo.23b8028.jpg";

/***/ }),

/***/ "ayFF":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (selector, options) {
    var $container = $("" + selector);
    var data = options.data;

    data.navs.map(function (item) {
        if (item.pcTitle) {
            item.title = item.pcTitle;
        }
    });
    //data.navs = sortNavsByDate(data.navs);

    render(data);
    fixTop(handleOffsetTop(data.offsetTop));
    if (data.smoothScroll) {
        bindSmoothScroll(data);
    }

    function handleOffsetTop(offsetTop) {
        offsetTop = +offsetTop;
        offsetTop = isNaN(offsetTop) ? 0 : offsetTop;

        return offsetTop;
    }

    function render(data) {
        var html = (0, _index2.default)(data);
        $container.html(html);
    }

    function fixTop(offsetTop) {
        var $el = $container.find(".blocks-navbar-pc-affix");
        var $affix = $container.find(".blocks-navbar-pc-affix .affix");
        // 垫片dom，在affix元素fixed时占位
        var $shim = $container.find(".blocks-navbar-pc-affix .shim");

        $(window).on("scroll", function (ev) {
            var scrollTop = getScroll(window, true);
            var elOffset = getOffset($el.get(0));

            if (elOffset.top - offsetTop <= scrollTop) {
                $affix.addClass("fixed").css("top", offsetTop).css("width", $el.get(0).offsetWidth);

                $shim.css("display", "");
                $shim.css("width", $el.get(0).clientWidth);
                $shim.css("height", $affix.get(0).clientHeight);
            } else {
                $affix.removeClass("fixed").css("width", "");

                $shim.css("display", "none");
            }
        });
    }

    function getScroll(target, top) {
        var prop = top ? "pageYOffset" : "pageXOffset";
        var method = top ? "scrollTop" : "scrollLeft";
        var ret = target[prop];
        if (typeof ret !== "number") {
            ret = window.document.documentElement[method];
        }
        return ret;
    }

    function getOffset(element) {
        var rect = element.getBoundingClientRect();
        var scrollTop = getScroll(window, true);
        var scrollLeft = getScroll(window);
        var docEl = window.document.body;
        var clientTop = docEl.clientTop || 0;
        var clientLeft = docEl.clientLeft || 0;
        return {
            top: rect.top + scrollTop - clientTop,
            left: rect.left + scrollLeft - clientLeft
        };
    }

    function bindSmoothScroll(data) {
        var smoothScrollOffset = data.smoothScrollOffset || 0;
        $container.on("click", ".affix ul li", function (ev) {
            var $el = $(ev.currentTarget);
            var anchor = $el.attr("data-anchor");
            var $anchor = $(anchor);

            if (!$anchor.length) {
                throw new Error("导航对应的锚点dom不存在");
            }
            var scrollTop = getScroll(window, true);
            var top = $anchor.get(0).getBoundingClientRect().top + scrollTop - smoothScrollOffset;
            $("html, body").animate({ scrollTop: top }, 500);
        });
    }

    // 根据日期变换nav顺序
    function sortNavsByDate(navs) {
        var spot = new Date("2019-01-17 00:00:00").getTime();

        if (Date.now() > spot) {
            var living = navs.splice(4, 1)[0];
            navs.unshift(living);
        }

        return navs;
    }
};

__webpack_require__("y4l9");

var _index = __webpack_require__("5WOt");

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ "cK//":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "//game.gtimg.cn/images/game/act/a20181206tgc/img/qr-lg.0bf507d.jpg";

/***/ }),

/***/ "d9Wh":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "dk2q":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate, global) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = promisePolyfill;
function promisePolyfill() {

  if (window.Promise) {
    return;
  }

  /**
   * @this {Promise}
   */
  function finallyConstructor(callback) {
    var constructor = this.constructor;
    return this.then(function (value) {
      return constructor.resolve(callback()).then(function () {
        return value;
      });
    }, function (reason) {
      return constructor.resolve(callback()).then(function () {
        return constructor.reject(reason);
      });
    });
  }

  // Store setTimeout reference so promise-polyfill will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var setTimeoutFunc = setTimeout;

  function noop() {}

  // Polyfill for Function.prototype.bind
  function bind(fn, thisArg) {
    return function () {
      fn.apply(thisArg, arguments);
    };
  }

  /**
   * @constructor
   * @param {Function} fn
   */
  function Promise(fn) {
    if (!(this instanceof Promise)) throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('not a function');
    /** @type {!number} */
    this._state = 0;
    /** @type {!boolean} */
    this._handled = false;
    /** @type {Promise|undefined} */
    this._value = undefined;
    /** @type {!Array<!Function>} */
    this._deferreds = [];

    doResolve(fn, this);
  }

  function handle(self, deferred) {
    while (self._state === 3) {
      self = self._value;
    }
    if (self._state === 0) {
      self._deferreds.push(deferred);
      return;
    }
    self._handled = true;
    Promise._immediateFn(function () {
      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
        return;
      }
      var ret;
      try {
        ret = cb(self._value);
      } catch (e) {
        reject(deferred.promise, e);
        return;
      }
      resolve(deferred.promise, ret);
    });
  }

  function resolve(self, newValue) {
    try {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
      if (newValue && ((typeof newValue === 'undefined' ? 'undefined' : _typeof(newValue)) === 'object' || typeof newValue === 'function')) {
        var then = newValue.then;
        if (newValue instanceof Promise) {
          self._state = 3;
          self._value = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(bind(then, newValue), self);
          return;
        }
      }
      self._state = 1;
      self._value = newValue;
      finale(self);
    } catch (e) {
      reject(self, e);
    }
  }

  function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    finale(self);
  }

  function finale(self) {
    if (self._state === 2 && self._deferreds.length === 0) {
      Promise._immediateFn(function () {
        if (!self._handled) {
          Promise._unhandledRejectionFn(self._value);
        }
      });
    }

    for (var i = 0, len = self._deferreds.length; i < len; i++) {
      handle(self, self._deferreds[i]);
    }
    self._deferreds = null;
  }

  /**
   * @constructor
   */
  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */
  function doResolve(fn, self) {
    var done = false;
    try {
      fn(function (value) {
        if (done) return;
        done = true;
        resolve(self, value);
      }, function (reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      });
    } catch (ex) {
      if (done) return;
      done = true;
      reject(self, ex);
    }
  }

  Promise.prototype['catch'] = function (onRejected) {
    return this.then(null, onRejected);
  };

  Promise.prototype.then = function (onFulfilled, onRejected) {
    // @ts-ignore
    var prom = new this.constructor(noop);

    handle(this, new Handler(onFulfilled, onRejected, prom));
    return prom;
  };

  Promise.prototype['finally'] = finallyConstructor;

  Promise.all = function (arr) {
    return new Promise(function (resolve, reject) {
      if (!arr || typeof arr.length === 'undefined') throw new TypeError('Promise.all accepts an array');
      var args = Array.prototype.slice.call(arr);
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        try {
          if (val && ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' || typeof val === 'function')) {
            var then = val.then;
            if (typeof then === 'function') {
              then.call(val, function (val) {
                res(i, val);
              }, reject);
              return;
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise.resolve = function (value) {
    if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.constructor === Promise) {
      return value;
    }

    return new Promise(function (resolve) {
      resolve(value);
    });
  };

  Promise.reject = function (value) {
    return new Promise(function (resolve, reject) {
      reject(value);
    });
  };

  Promise.race = function (values) {
    return new Promise(function (resolve, reject) {
      for (var i = 0, len = values.length; i < len; i++) {
        values[i].then(resolve, reject);
      }
    });
  };

  // Use polyfill for setImmediate for performance gains
  Promise._immediateFn = typeof setImmediate === 'function' && function (fn) {
    setImmediate(fn);
  } || function (fn) {
    setTimeoutFunc(fn, 0);
  };

  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
    if (typeof console !== 'undefined' && console) {
      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    }
  };

  /** @suppress {undefinedVars} */
  var globalNS = function () {
    // the only reliable means to get the global object is
    // `Function('return this')()`
    // However, this causes CSP violations in Chrome apps.
    if (typeof self !== 'undefined') {
      return self;
    }
    if (typeof window !== 'undefined') {
      return window;
    }
    if (typeof global !== 'undefined') {
      return global;
    }
    throw new Error('unable to locate global object');
  }();

  if (!('Promise' in globalNS)) {
    globalNS['Promise'] = Promise;
  } else if (!globalNS.Promise.prototype['finally']) {
    globalNS.Promise.prototype['finally'] = finallyConstructor;
  }
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("162o").setImmediate, __webpack_require__("DuR2")))

/***/ }),

/***/ "fdFc":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.handleResponse = handleResponse;
exports.formatV4NewsData = formatV4NewsData;
exports.getNewsDetailUrl = getNewsDetailUrl;
exports.formatV4RedirectData = formatV4RedirectData;
exports.extractV4CoverImg = extractV4CoverImg;
exports.getRandomScriptObjName = getRandomScriptObjName;
exports.findDomByClass = findDomByClass;
exports.hideElsForEmbedingLittleProgram = hideElsForEmbedingLittleProgram;
exports.getUrlParameter = getUrlParameter;
exports.showMask = showMask;
exports.hideMask = hideMask;
exports.isInMiniProgram = isInMiniProgram;
exports.makePcFrameworkCenter = makePcFrameworkCenter;

var _lodash = __webpack_require__("y3TV");

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 浮层遮罩的class，需要放在.wrapper下
var maskClass = "global-mask";

/**
 * 处理v4返回的数据格式
 * @param {Object} res
 * @param {string} type 数据类型，资讯列表和详情的数据格式略有不同
 */
function handleResponse(res) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "list";

    if (res.status !== 0) {
        return {
            failed: true,
            msg: res.msg
        };
    }

    var ret = void 0;
    switch (type) {
        case "list":
            ret = res.msg.result;
            break;
        case "detail":
            ret = res.msg;
            break;
    }

    return ret;
}

/**
 * 把新闻列表的v4的属性转成组件通用的属性
 * @param {Object} item
 * @param {string} type pc or m
 * @return {Object}
 */
function formatV4NewsData(_ref) {
    var item = _ref.item,
        type = _ref.type;

    return {
        id: item.iNewsId,
        title: item.sTitle,
        url: item.sUrl || getNewsDetailUrl({ id: item.iNewsId, type: type }),
        img: item.sIMG,
        time: item.sIdxTime.split(" ")[0]
    };
}

function getNewsDetailUrl(_ref2) {
    var id = _ref2.id,
        type = _ref2.type;

    return "/2019" + (type === "pc" ? "" : "/m") + "/newsdetail.html?newsid=" + id;
}

/**
 * 把跳转类（轮播图，没有详情页，只需要跳转链接）的v4属性转换成通用属性
 * @param {Object} item
 * @return {Object}
 */
function formatV4RedirectData(item) {
    return {
        title: item.sTitle,
        url: item.sRedirectURL,
        img: item.sIMG
    };
}

/**
 * 从v4数据的sCoverMap字段中提取第一张图片的url
 * @param {string} coverMap
 * @return {string}
 */
function extractV4CoverImg(coverMap) {
    var o = JSON.parse(coverMap);
    return (0, _lodash2.default)(o, "One.Url");
}

/**
 * 随机变量名
 */
function getRandomScriptObjName() {
    return "NewsObj" + Date.now() + Math.round(Math.random() * 1000);
}

/**
 * 查找一个dom，如果不存在则创建一个
 * @param {string} selector 需要查找的dom的选择器
 * @param {string|Function?} html dom的html结构，如果dom不存在则需要用它创建dom
 * @param {string?} appendClass 该dom的上层dom的选择器，如果dom不存在则append到它里面
 *
 * @return {DOM}
 */
function findDomByClass(_ref3) {
    var selector = _ref3.selector,
        html = _ref3.html,
        appendClass = _ref3.appendClass;

    var $dom = $(selector);
    if (!$dom.length) {
        if (!html) {
            return null;
        }

        if (typeof html === "function") {
            $dom = $(html());
        } else {
            $dom = $(html);
        }
        $(appendClass).append($dom);
    }

    return $dom;
}

/**
 * 在小程序内嵌官网页面时，根据query标识决定隐藏一些元素
 */
function hideElsForEmbedingLittleProgram() {
    return isInMiniProgram().then(function (ret) {
        if (ret) {
            $(".btn-ticket-entrance").hide();
            $(".mod-navbar").hide();
            $(".blocks-lp-qrcode").hide();
            // logo墙所有的链接不跳转
            var $p = $(".blocks-partners");
            if ($p.length) {
                $p.find(".list a").attr("href", "javascript:;");
            }
            // 所有文创的
            var $gg = $(".blocks-carousel-gg");
            if ($gg.length) {
                $gg.find('.swiper-slide a').attr("href", "javascript:;");
            }
            if (location.href.indexOf("/scene.html") > -1) {
                $(".mod-kv").hide();
                $(".wrapper").css("background", "#fff");
                setTimeout(function () {
                    $(".blocks-tabs-scene .tabs").hide();
                }, 300);
            }
        }
    }).catch(function (err) {
        console.log(err);
    });
}

function getUrlParameter(name) {
    name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
    var regex = new RegExp("[\\?&]" + name + "=([^&#]*)");
    var results = regex.exec(location.search);
    return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
}

function showMask() {
    var $mask = $(".wrapper ." + maskClass);
    $mask.show();
}

function hideMask() {
    $(".wrapper ." + maskClass).hide();
}

function isInMiniProgram() {
    return new Promise(function (resolve) {
        if (!wx || !wx.miniProgram) {
            return Promise.resolve(false);
        }

        wx.miniProgram.getEnv(function (res) {
            console.log(res.miniprogram); // true
            resolve(res.miniprogram);
        });
    });
}

// 让pc页面的主体居中显示，如果被遮挡的话
function makePcFrameworkCenter() {
    var winW = $(window).width();
    var $brand = $('.row-brand .mod-brand-video');
    var brandW = $brand.width();
    var $body = $('.body-wrapper');
    var bodyW = $body.width();

    if (brandW > winW) {
        $brand.css('left', -(brandW - winW) / 2);
    }
    if (bodyW > winW) {
        $body.css('left', -(bodyW - winW) / 2);
    }
}

/***/ }),

/***/ "j8AK":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (selector) {
    $container = $(selector);
    bindEvent();

    Promise.all([loading(), initMap()]);
};

__webpack_require__("y8up");

var _iscrollZoom = __webpack_require__("Fl7+");

var _iscrollZoom2 = _interopRequireDefault(_iscrollZoom);

var _swiper = __webpack_require__("gsqX");

var _swiper2 = _interopRequireDefault(_swiper);

__webpack_require__("v2ns");

var _v4DataService = __webpack_require__("lbly");

var _mapPc = __webpack_require__("Ow/d");

var _mapPc2 = _interopRequireDefault(_mapPc);

var _mapGuide = __webpack_require__("rzXR");

var _mapGuide2 = _interopRequireDefault(_mapGuide);

var _gameCard = __webpack_require__("KUwY");

var _gameCard2 = _interopRequireDefault(_gameCard);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// iscroll对象，控制整个地图
var mapScroll = void 0;
// 游戏点介绍卡片的轮播swiper对象
var gameCardController = void 0;
var $container = void 0;
var translateDuration = 500;
var zoomMax = 2;
// zoom时x轴的基准偏移
var xBase = 1000 / 2;
// zoom时y轴的基准偏移
var yBase = 1303;
var mapData = void 0;
var imgH = 755;
var mapH = 1100;

function loading() {
    return Promise.resolve();
}

function initMap() {
    return (0, _v4DataService.getMapData)().then(handleZlkData).then(function (data) {
        console.log(data);
        mapData = data;
        renderMapGuideTabContent(data); // 热区数据
        initScroll();
    });
}

function initScroll() {
    mapScroll = new _iscrollZoom2.default("#map", {
        bounce: false,
        zoom: true,
        zoomMax: zoomMax,
        zoomMin: getZoomMin(),
        scrollX: true,
        scrollY: true
        // mouseWheel: true,
        // wheelAction: "zoom"
    });
}

function renderMapGuideTabContent(data) {
    var html = (0, _mapGuide2.default)(data);
    $container.html(html);
}

function bindEvent() {
    // 点击tab
    $container.on("click", ".venue-tabs .venue-tab-item", onClickTabs);
    // 点击热区
    $container.on("click", ".map .hotarea", onClickHotarea);
    // 点击返回按钮
    $container.on("click", ".map-wrapper .btn-map-back", onClickBack);
    // 点击关闭游戏点介绍按钮
    $container.on("click", ".game-point-card .btn-close", hideGameCard);
    // 点击体验点介绍的导航按钮
    $container.on("click", ".game-point-card .experiences .btn-nav", onClickNav);
    // 点击游戏点列表中的checkbox
    $container.on("click", ".game-point-list .game-point-item", onClickGamePoint);
    // 点击隐藏游戏点列表
    $container.on('click', '.game-point-list .btn-hide-game-list', hideGamePointList);
    // 点击显示游戏点列表
    $container.on('click', '.btn-show-game-list', showGamePointList);
    // 在鼠标移动到地图区域时，禁止外层滚动
    // $container
    //     .on("mouseenter", ".map-wrapper", () =>
    //         $("body").css("overflow", "hidden")
    //     )
    //     .on("mouseleave", ".map-wrapper", () =>
    //         $("body").css("overflow", "auto")
    //     );
}

function showGamePointList() {
    $container.find('.game-point-list').show();
    $container.find('.btn-show-game-list').hide();
}

function hideGamePointList() {
    $container.find('.game-point-list').hide();
    $container.find('.btn-show-game-list').show();
}

function onClickBack() {
    mapScroll.zoom(1);
}

var isFirstClickTabs = true;
function onClickTabs(ev) {
    var $el = $(ev.currentTarget);
    // 激活tab
    $el.addClass("on").siblings().removeClass("on");

    var mapTag = $el.attr("data-map");
    var $hotarea = getHotareaElByTag(mapTag);
    if ($hotarea.length) {
        moveTo($hotarea);
        unactiveGamePoint();
        if (mapTag !== 'ip') {
            showGameCard(mapTag);
        } else {
            hideGameCard(mapTag);
        }
    }
    if (isFirstClickTabs) {
        isFirstClickTabs = false;
        $container.find(".venue-tabs").css('margin-bottom', 200);
    }
    if (mapTag === 'ip') {
        showGamePointList();
    } else {
        hideGamePointList();
    }
}

function onClickHotarea(ev) {
    var $el = $(ev.currentTarget);
    var mapTag = $el.attr("data-map");

    moveTo($el);
    showGameCard(mapTag);
    activeGamePoint({ tag: mapTag });
}

function showGameCard(tag) {
    var data = getHotareaDataByTag(tag);

    if (!data) {
        throw new Error(tag + " \u5BF9\u5E94\u7684\u6570\u636E\u4E0D\u5B58\u5728");
    }

    var $card = $container.find(".game-point-card");
    var curKey = $card.attr("data-key");
    var isShow = $card.is(":visible");
    if (curKey === data.key_52) {
        if (!isShow) {
            $card.show();
        }

        return;
    }

    var html = (0, _gameCard2.default)(data);
    $card.html(html);
    // gameCardController = new Swiper(
    //     $card.find(".experiences .swiper-container").get(0),
    //     {
    //         // gameCardController = new Swiper('.game-point-card .experiences .swiper-container', {
    //         slidesPerView: "auto",
    //         allowTouchMove: false
    //     }
    // );

    if (!isShow) {
        $card.show();
        // gameCardController.update();
    }
}

function hideGameCard() {
    $container.find(".game-point-card").hide();
}

function onClickNav(ev) {
    var $el = $(ev.currentTarget);
    if ($el.hasClass("btn-nav-prev")) {
        gameCardController.slidePrev();
    } else {
        gameCardController.slideNext();
    }
}

function onClickGamePoint(ev) {
    var $el = $(ev.currentTarget);
    var tag = $el.attr("data-map");
    var $hotarea = getHotareaElByTag(tag);

    activeGamePoint({ $el: $el });
    showGameCard(tag);
    moveTo($hotarea);
}

function activeGamePoint(_ref) {
    var $el = _ref.$el,
        tag = _ref.tag;

    if (tag && typeof tag === "string") {
        $el = $container.find(".game-point-list .game-point-item[data-map=\"" + tag + "\"]");
    }

    if ($el && $el.length) {
        $container.find('.game-point-list .game-point-item').removeClass("on");
        $el.addClass("on");
    }
}

function unactiveGamePoint() {
    $container.find(".game-point-list .game-point-item").removeClass("on");
}

function getHotareaDataByTag(tag) {
    var _mapData = mapData,
        list = _mapData.list;

    var ret = void 0;

    list.map(function (item) {
        if (item.key_52 === tag) {
            ret = item;
        }
    });

    return ret;
}

function getHotareaElByTag(tag) {
    return $container.find(".hotarea-list .hotarea-" + tag);
}

function moveTo($el) {
    var _$el$position = $el.position(),
        left = _$el$position.left,
        top = _$el$position.top;

    var scale = mapScroll.scale;
    var leftByScale = Math.round(left / scale);
    var topByScale = Math.round(top / scale);

    if (scale === zoomMax) {
        mapScroll.scrollTo(-leftByScale, -topByScale, translateDuration);
        // mapScroll.scrollToElement($el.get(0));
    } else {
        mapScroll.zoom(zoomMax, xBase + left, yBase + top, translateDuration);
        // mapScroll.zoom(zoomMax, xBase + left, 1303 + top, translateDuration);
    }
    setHotareaActive($el);
}

function setHotareaActive($el) {
    $el.addClass("visited").siblings().removeClass("visited");
}

/**
 * 主题区的"ssztq_05"字段只有空格，这些数据在模板里为tabs字段,
 * 非主题区的热区数据聚合成list字段,
 * 游戏点的数据直接使用"pcdtydlb_b5"，在模板里为gamePoints字段,
 *
 * @param {Object} data
 */
function handleZlkData(data) {
    var list = [];
    var tabs = [];

    data["dtrq_3d"].map(function (item) {
        var belong = item["ssztq_05"].replace(/\s+/g, "");

        if (!belong) {
            tabs.push(item);
        }
        list.push(item);
    });

    return {
        list: list,
        tabs: mockTabData(tabs),
        gamePoints: makeGamePointListColumn(data["pcdtydlb_b5"]["dtrq_3d"]),
        mapImg: _mapPc2.default
    };
}

function makeGamePointListColumn(list) {
    var columnCount = 3;
    var ret = [];
    for (var i = 0; i < columnCount; i++) {
        ret[i] = [];
    }

    list.map(function (item, i) {
        var index = i % columnCount;
        ret[index].push(item);
    });

    return ret;
}

function mockTabData(tabs) {
    var len = tabs.length;
    if (len < 5) {
        for (var i = 0; i < 5 - len; i++) {
            tabs.push(tabs[0]);
        }
    }

    return tabs;
}

function getZoomMin() {
    return (mapH / imgH).toFixed(2);
}

/***/ }),

/***/ "jxHD":
/***/ (function(module, exports, __webpack_require__) {

var $imports = __webpack_require__("+ObC");
module.exports = function ($data) {
    'use strict';
    $data = $data || {};
    var $$out = '';
    $$out += '<div class="blocks-map-info">\r\n    <div class="header">新世纪环球中心</div>\r\n    <div class="lines">\r\n        <div class="line">\r\n            <strong>地址\uFF1A</strong>\r\n            <span>成都武侯区天府大道北段1700号</span>\r\n        </div>\r\n        <div class="line">\r\n            <strong>地铁线路\uFF1A</strong>\r\n            锦城广场\uFF081号线\uFF09\r\n        </div>\r\n        <div class="line">\r\n            <strong>公交线路\uFF1A</strong>\r\n            环球中心站\uFF0874\uFF0C125\uFF0C171a\uFF0C801\uFF09\r\n        </div>\r\n    </div>\r\n    <div class="cards">\r\n        <div class="card">\r\n            <div class="stop">\r\n                <div class="ch">成都站</div>\r\n                <div class="en">CHENGDU</div>\r\n                <div class="icon-line"></div>\r\n                <p class="miles">约20.1公里</p>\r\n            </div>\r\n            <p class="arrival">新世纪环球中心</p>\r\n        </div>\r\n        <div class="card">\r\n            <div class="stop">\r\n                <div class="ch">成都东站</div>\r\n                <div class="en">CHENGDU</div>\r\n                <div class="icon-line"></div>\r\n                <p class="miles">约13.8公里</p>\r\n            </div>\r\n            <p class="arrival">新世纪环球中心</p>\r\n        </div>\r\n        <div class="card">\r\n            <div class="stop">\r\n                <div class="ch">成都南站</div>\r\n                <div class="en">CHENGDU</div>\r\n                <div class="icon-line"></div>\r\n                <p class="miles">约4.2公里</p>\r\n            </div>\r\n            <p class="arrival">新世纪环球中心</p>\r\n        </div>\r\n        <div class="card">\r\n            <div class="stop">\r\n                <div class="ch">双流国际机场</div>\r\n                <div class="en">CHENGDU</div>\r\n                <div class="icon-line"></div>\r\n                <p class="miles">约14.8公里</p>\r\n            </div>\r\n            <p class="arrival">新世纪环球中心</p>\r\n        </div>\r\n    </div>\r\n    <div class="around-map" id="around-map"></div>\r\n</div>\r\n';
    return $$out;
};

/***/ }),

/***/ "lbly":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getV4NewsTabsData = getV4NewsTabsData;
exports.getV4TagNewsData = getV4TagNewsData;
exports.getNewsCarouselData = getNewsCarouselData;
exports.getPartnersData = getPartnersData;
exports.getCCIData = getCCIData;
exports.getAdsData = getAdsData;
exports.getMapData = getMapData;

var _utils = __webpack_require__("fdFc");

var _getScriptFx = __webpack_require__("X6PD");

var _getScriptFx2 = _interopRequireDefault(_getScriptFx);

var _index = __webpack_require__("3guR");

var _index2 = _interopRequireDefault(_index);

var _promisePolyfill = __webpack_require__("dk2q");

var _promisePolyfill2 = _interopRequireDefault(_promisePolyfill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _promisePolyfill2.default)();

(0, _getScriptFx2.default)($);

var v4ApiPrefix = "//apps.game.qq.com/wmp/v3.1/";
var mapZlkUrl = "//grsm.qq.com/zlkdatasys/zlkdatasys/data_zlk_tgc2018cgzydt.json";

function getV4TagNewsApiUrl(_ref) {
    var bizId = _ref.bizId,
        id = _ref.id,
        source = _ref.source,
        objName = _ref.objName;

    return v4ApiPrefix + "?p0=" + bizId + "&p1=searchNewsKeywordsList&order=sIdxTime&r0=script&r1=" + objName + "&type=iTag&id=" + id + "&source=" + source;
}
/**
 * 用Gicp数据插件请求资讯tabs的数据
 * @param {Object} params
 *
 * @return {Promise}
 */
function getV4NewsTabsData(_ref2) {
    var bizId = _ref2.bizId,
        tabs = _ref2.tabs,
        source = _ref2.source,
        pageSize = _ref2.pageSize,
        type = _ref2.type,
        tag = _ref2.tag,
        formateFn = _ref2.formateFn;

    var promises = tabs.map(function (item, index) {
        return new Promise(function (resolve, reject) {
            var opt = {
                gameID: bizId, // 不同游戏不一样，需要咨询内部重构
                type: item.tag ? item.tag : "iTag", // 查询类型（一级分类：iType，二级分类：iSubType，关键字：iKeyword，推荐位：iTarget;标签：iTag；不传该参数时，查询全部分类的内容，但最多只返回240条内容）
                id: item.id, //类型id，可多个，英文逗号分隔，在gicp建完频道就能看到
                newsType: "news", //news | video 图文新闻或者视频新闻
                pure: true,
                source: source, //数据上报用的，表明本页面用于pc或者移动；在gicp建，常见的移动官网是web_m ，PC官网是 web_pc
                detailURL: "/2019" + (type === "pc" ? "" : "/m") + "/newsdetail.html", // 新闻的详情页，会在后面加上?newsid=XXX
                callback: function callback(res) {
                    var ret = (0, _utils.handleResponse)(res);

                    if (ret.failed) {
                        console.log("\u8BF7\u6C42\u6807\u7B7Eid: " + item.id + "\u5931\u8D25");
                        resolve({
                            title: item.title,
                            list: []
                        });
                        // reject({
                        //     msg: ret.msg,
                        //     id: item.id
                        // });
                    } else {
                        // 格式化每条新闻的字段
                        var list = ret.map(function (item) {
                            if (formateFn && typeof formateFn === 'function') {
                                return formateFn.call(null, { item: item, type: type });
                            }
                            return (0, _utils.formatV4NewsData)({ item: item, type: type });
                        });

                        resolve({
                            title: item.title,
                            list: list
                        });
                    }
                }
            };
            if (pageSize) {
                opt.pageSize = pageSize; // 每一页文章条数
            }
            if (item.page) {
                opt.page = item.page;
            }

            fillNews.list(opt);
        });
    });

    return Promise.all(promises);
}

/**
 * 获取v4标签新闻类数据
 * @param {Object}
 */
function getV4TagNewsData(_ref3) {
    var bizId = _ref3.bizId,
        source = _ref3.source,
        id = _ref3.id;

    return new Promise(function (resolve, reject) {
        var objName = (0, _utils.getRandomScriptObjName)();
        var url = getV4TagNewsApiUrl({
            bizId: bizId,
            id: id,
            source: source,
            objName: objName
        });
        $.getScript(url, function () {
            var res = window[objName];
            if (!res) {
                return reject(new Error("\u8BF7\u6C42" + url + "\u5931\u8D25"));
            }

            return resolve(res);
        });
    });
}

/**
 * 取新闻轮播图的数据
 * @param {string} type
 */
function getNewsCarouselData(type) {
    return getV4TagNewsData({
        bizId: _index2.default.gicpBizId,
        source: type === "pc" ? "web_pc" : "web_m",
        id: _index2.default.newsCarousel[type]
    }).then(function (res) {
        var ret = (0, _utils.handleResponse)(res);
        if (ret.failed) {
            return Promise.reject(new Error("\u8BF7\u6C42\u65B0\u95FB\u8F6E\u64AD\u56FE\u6570\u636E\u5931\u8D25, msg: " + ret.msg));
        } else {
            var list = ret.map(_utils.formatV4RedirectData);
            return Promise.resolve(list);
        }
    });
}

/**
 * 取合作伙伴数据
 * @param {string} type 
 */
function getPartnersData(type) {
    return getV4NewsTabsData({
        bizId: _index2.default.gicpBizId,
        tabs: _index2.default.partners[type],
        source: type === "pc" ? "web_pc" : "web_m",
        pageSize: 100,
        type: type,
        formateFn: function formateFn(_ref4) {
            var item = _ref4.item;

            return (0, _utils.formatV4RedirectData)(item);
        }
    }).then(function (list) {
        var displayLogo1 = list[3];
        var displayLogo2 = list[4];
        if (displayLogo1.title === displayLogo2.title) {
            var merge = displayLogo1.list.concat(displayLogo2.list);
            displayLogo1.list = merge;
            list.splice(4, 1);
        }
        return list;
    });
}

/**
 * 获取四大文创数据
 * @param {string} type pc or m
 */
function getCCIData(type) {
    return getV4TagNewsData({
        bizId: _index2.default.gicpBizId,
        source: type === "pc" ? "web_pc" : "web_m",
        id: _index2.default.cci[type]
    }).then(function (res) {
        var ret = (0, _utils.handleResponse)(res);
        if (ret.failed) {
            return Promise.reject(new Error("\u8BF7\u6C42\u56DB\u5927\u6587\u521B\u6570\u636E\u5931\u8D25, msg: " + ret.msg));
        } else {
            var list = ret.map(_utils.formatV4RedirectData);
            return Promise.resolve(list);
        }
    });
}

/**
 * 获获取广告位数据
 * @param {string} type pc or m
 */
function getAdsData(type) {
    return getV4TagNewsData({
        bizId: _index2.default.gicpBizId,
        source: type === "pc" ? "web_pc" : "web_m",
        id: _index2.default.ads[type]
    }).then(function (res) {
        var ret = (0, _utils.handleResponse)(res);
        if (ret.failed) {
            return Promise.reject(new Error("\u8BF7\u6C42\u5E7F\u544A\u4F4D\u6570\u636E\u5931\u8D25, msg: " + ret.msg));
        } else {
            var list = ret.map(_utils.formatV4RedirectData);
            return Promise.resolve(list);
        }
    });
}

/**
 * 从资料库获取map相关的数据
 */
function getMapData() {
    return new Promise(function (resolve, reject) {
        $.ajax({
            type: 'GET',
            url: mapZlkUrl,
            dataType: 'jsonp',
            jsonpCallback: 'mapCallback',
            success: function success(data) {
                resolve(data);
            },
            error: function error(err) {
                reject(err);
            }
        });
    });
}

/***/ }),

/***/ "n8ar":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (selector, options) {
    var $container = $(selector);

    init();

    function init() {
        render();
    }

    function render() {
        var html = (0, _index2.default)();
        $container.html(html);
    }
};

__webpack_require__("Y4eA");

var _index = __webpack_require__("Ib5e");

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ "rzXR":
/***/ (function(module, exports, __webpack_require__) {

var $imports = __webpack_require__("+ObC");
module.exports = function ($data) {
    'use strict';
    $data = $data || {};
    var $$out = '', $each = $imports.$each, tabs = $data.tabs, tab = $data.tab, index = $data.index, $escape = $imports.$escape, gamePoints = $data.gamePoints, column = $data.column, item = $data.item, list = $data.list, mapImg = $data.mapImg;
    $$out += '<div class="venue-tabs">\r\n    <ul>\r\n        ';
    $each(tabs, function (tab, index) {
        $$out += '\r\n        <li class="venue-tab-item" data-map="';
        $$out += $escape(tab.key_52);
        $$out += '">\r\n            <a href="javascript:;">\r\n                <h2 class="item-title">';
        $$out += $escape(tab.zwmc_8b);
        $$out += '</h2>\r\n            </a>\r\n            <p class="item-desc">';
        $$out += $escape(tab.jj_e7);
        $$out += '</p>\r\n        </li>\r\n        ';
    });
    $$out += '\r\n    </ul>\r\n</div>\r\n\r\n<div class="map-wrapper">\r\n    <!-- 返回全地图按钮 -->\r\n    <div class="btn-map-back"></div>\r\n    <!-- 地图右上角的主题介绍 -->\r\n    <div class="game-point-card"></div>\r\n    <!-- 显示游戏点卡片 -->\r\n    <div class="btn-show-game-list"></div>\r\n    <!-- 地图右下角的游戏点卡片 -->\r\n    <div class="game-point-list">\r\n        <div class="btn-hide-game-list"></div>\r\n        ';
    $each(gamePoints, function (column, index) {
        $$out += '\r\n        <div class="column">\r\n        ';
        $each(column, function (item, index) {
            $$out += '\r\n            <a href="javascript:;" class="game-point-item" data-map="';
            $$out += $escape(item.key_52);
            $$out += '"><p class="item-name">';
            $$out += $escape(item.zwmcjx_af);
            $$out += '</p></a>\r\n        ';
        });
        $$out += '\r\n        </div>\r\n        ';
    });
    $$out += '\r\n    </div>\r\n\r\n    <div id="map" class="map">\r\n        <div class="map-inner">\r\n\r\n            <!-- 地图上的热区 -->\r\n            <div class="hotarea-list">\r\n                ';
    $each(list, function (item, index) {
        $$out += '\r\n                <a class="hotarea-';
        $$out += $escape(item.key_52);
        $$out += ' hotarea" href="javascript:;" data-map="';
        $$out += $escape(item.key_52);
        $$out += '"><div class="map-mark"></div></a>\r\n                ';
    });
    $$out += '\r\n            </div>\r\n\r\n            <!-- 地图位置图标 -->\r\n            <!-- <div class="map-mark"></div> -->\r\n\r\n            <img class="map-img" id="map-img" src="';
    $$out += $escape(mapImg);
    $$out += '" alt="地图">\r\n        </div>\r\n    </div>\r\n</div>';
    return $$out;
};

/***/ }),

/***/ "skTu":
/***/ (function(module, exports, __webpack_require__) {

var $imports = __webpack_require__("+ObC");
module.exports = function ($data) {
    'use strict';
    $data = $data || {};
    var $$out = '', $each = $imports.$each, list = $data.list, item = $data.item, index = $data.index, $escape = $imports.$escape, line = $data.line;
    $$out += '<div class="tab-content-helps">\r\n    <div class="helps-list">\r\n        ';
    $each(list, function (item, index) {
        $$out += '\r\n        <div class="helps-item">\r\n            <i class="num num-';
        $$out += $escape(index + 1);
        $$out += '"></i>\r\n            <h2 class="title">';
        $$out += $escape(item.title);
        $$out += '</h2>\r\n            <div class="lines">\r\n                ';
        $each(item.lines, function (line, index) {
            $$out += '\r\n                <div class="line">';
            $$out += line;
            $$out += '</div>\r\n                ';
        });
        $$out += '\r\n            </div>\r\n        </div>\r\n        ';
    });
    $$out += '\r\n    </div>\r\n</div>';
    return $$out;
};

/***/ }),

/***/ "v2ns":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "y4l9":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "y8up":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ })

},["9y5s"]);